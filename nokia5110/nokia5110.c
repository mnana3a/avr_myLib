#include "nokia5110.h"

uint8_t gu8yLoc = 0;
uint8_t gu8xLoc = 0;

uint8_t mapArray[504] = {0x00};

#ifndef __USE_BOLD_FONT
static const uint8_t ASCII[][5] PROGMEM = {
  // First 32 characters (0x00-0x19) are ignored. These are
  // non-displayable, control characters.
   {0x00, 0x00, 0x00, 0x00, 0x00} // 0x20
  ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 0x21 !
  ,{0x00, 0x07, 0x00, 0x07, 0x00} // 0x22 "
  ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 0x23 #
  ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 0x24 $
  ,{0x23, 0x13, 0x08, 0x64, 0x62} // 0x25 %
  ,{0x36, 0x49, 0x55, 0x22, 0x50} // 0x26 &
  ,{0x00, 0x05, 0x03, 0x00, 0x00} // 0x27 '
  ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 0x28 (
  ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 0x29 )
  ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 0x2a *
  ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 0x2b +
  ,{0x00, 0x50, 0x30, 0x00, 0x00} // 0x2c ,
  ,{0x08, 0x08, 0x08, 0x08, 0x08} // 0x2d -
  ,{0x00, 0x60, 0x60, 0x00, 0x00} // 0x2e .
  ,{0x20, 0x10, 0x08, 0x04, 0x02} // 0x2f /
  ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0x30 0
  ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 0x31 1
  ,{0x42, 0x61, 0x51, 0x49, 0x46} // 0x32 2
  ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 0x33 3
  ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 0x34 4
  ,{0x27, 0x45, 0x45, 0x45, 0x39} // 0x35 5
  ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 0x36 6
  ,{0x01, 0x71, 0x09, 0x05, 0x03} // 0x37 7
  ,{0x36, 0x49, 0x49, 0x49, 0x36} // 0x38 8
  ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 0x39 9
  ,{0x00, 0x36, 0x36, 0x00, 0x00} // 0x3a :
  ,{0x00, 0x56, 0x36, 0x00, 0x00} // 0x3b ;
  ,{0x08, 0x14, 0x22, 0x41, 0x00} // 0x3c <
  ,{0x14, 0x14, 0x14, 0x14, 0x14} // 0x3d =
  ,{0x00, 0x41, 0x22, 0x14, 0x08} // 0x3e >
  ,{0x02, 0x01, 0x51, 0x09, 0x06} // 0x3f ?
  ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 0x40 @
  ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 0x41 A
  ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 0x42 B
  ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 0x43 C
  ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 0x44 D
  ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 0x45 E
  ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 0x46 F
  ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 0x47 G
  ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 0x48 H
  ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 0x49 I
  ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 0x4a J
  ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 0x4b K
  ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 0x4c L
  ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 0x4d M
  ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 0x4e N
  ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 0x4f O
  ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 0x50 P
  ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 0x51 Q
  ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 0x52 R
  ,{0x46, 0x49, 0x49, 0x49, 0x31} // 0x53 S
  ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 0x54 T
  ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 0x55 U
  ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 0x56 V
  ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 0x57 W
  ,{0x63, 0x14, 0x08, 0x14, 0x63} // 0x58 X
  ,{0x07, 0x08, 0x70, 0x08, 0x07} // 0x59 Y
  ,{0x61, 0x51, 0x49, 0x45, 0x43} // 0x5a Z
  ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 0x5b [
  ,{0x02, 0x04, 0x08, 0x10, 0x20} // 0x5c \ (keep this to escape the backslash)
  ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
  ,{0x04, 0x02, 0x01, 0x02, 0x04} // 0x5e ^
  ,{0x40, 0x40, 0x40, 0x40, 0x40} // 0x5f _
  ,{0x00, 0x01, 0x02, 0x04, 0x00} // 0x60 `
  ,{0x20, 0x54, 0x54, 0x54, 0x78} // 0x61 a
  ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 0x62 b
  ,{0x38, 0x44, 0x44, 0x44, 0x20} // 0x63 c
  ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 0x64 d
  ,{0x38, 0x54, 0x54, 0x54, 0x18} // 0x65 e
  ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 0x66 f
  ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 0x67 g
  ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 0x68 h
  ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 0x69 i
  ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 0x6a j
  ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 0x6b k
  ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 0x6c l
  ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 0x6d m
  ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 0x6e n
  ,{0x38, 0x44, 0x44, 0x44, 0x38} // 0x6f o
  ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 0x70 p
  ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 0x71 q
  ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 0x72 r
  ,{0x48, 0x54, 0x54, 0x54, 0x20} // 0x73 s
  ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 0x74 t
  ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 0x75 u
  ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 0x76 v
  ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 0x77 w
  ,{0x44, 0x28, 0x10, 0x28, 0x44} // 0x78 x
  ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 0x79 y
  ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 0x7a z
  ,{0x00, 0x08, 0x36, 0x41, 0x00} // 0x7b {
  ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 0x7c |
  ,{0x00, 0x41, 0x36, 0x08, 0x00} // 0x7d }
  ,{0x10, 0x08, 0x08, 0x10, 0x08} // 0x7e ~
  ,{0x78, 0x46, 0x41, 0x46, 0x78} // 0x7f DEL
};
#else
static const uint8_t ASCII[][10] PROGMEM = {
  // First 32 characters (0x00-0x19) are ignored. These are
  // non-displayable, control characters.
   {0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00} // 0x20
  ,{0x00,0x00, 0x00,0x00, 0x5f,0x5f, 0x00,0x00, 0x00,0x00} // 0x21 !
  ,{0x00,0x00, 0x07,0x07, 0x00,0x07, 0x07,0x00, 0x00,0x00} // 0x22 "
  ,{0x14,0x14, 0x7f,0x7f, 0x14,0x14, 0x7f,0x7f, 0x14,0x14} // 0x23 #
  ,{0x24,0x24, 0x2a,0x2a, 0x7f,0x7f, 0x2a,0x2a, 0x12,0x12} // 0x24 $
  ,{0x23,0x23, 0x13,0x13, 0x08,0x08, 0x64,0x64, 0x62,0x62} // 0x25 %
  ,{0x36,0x36, 0x49,0x49, 0x55,0x55, 0x22,0x22, 0x50,0x50} // 0x26 &
  ,{0x00,0x00, 0x05,0x05, 0x03,0x03, 0x00,0x00, 0x00,0x00} // 0x27 '
  ,{0x00,0x00, 0x1c,0x1c, 0x22,0x22, 0x41,0x41, 0x00,0x00} // 0x28 (
  ,{0x00,0x00, 0x41,0x41, 0x22,0x22, 0x1c,0x1c, 0x00,0x00} // 0x29 )
  ,{0x14,0x14, 0x08,0x08, 0x3e,0x3e, 0x08,0x08, 0x14,0x14} // 0x2a *
  ,{0x08,0x08, 0x08,0x08, 0x3e,0x3e, 0x08,0x08, 0x08,0x08} // 0x2b +
  ,{0x00,0x00, 0x50,0x50, 0x30,0x30, 0x00,0x00, 0x00,0x00} // 0x2c ,
  ,{0x08,0x08, 0x08,0x08, 0x08,0x08, 0x08,0x08, 0x08,0x08} // 0x2d -
  ,{0x00,0x00, 0x60,0x60, 0x60,0x60, 0x00,0x00, 0x00,0x00} // 0x2e .
  ,{0x20,0x20, 0x10,0x10, 0x08,0x08, 0x04,0x04, 0x02,0x02} // 0x2f /
  ,{0x3e,0x3e, 0x51,0x51, 0x49,0x49, 0x45,0x45, 0x3e,0x3e} // 0x30 0
  ,{0x00,0x00, 0x42,0x42, 0x7f,0x7f, 0x40,0x40, 0x00,0x00} // 0x31 1
  ,{0x42,0x42, 0x61,0x61, 0x51,0x51, 0x49,0x49, 0x46,0x46} // 0x32 2
  ,{0x21,0x21, 0x41,0x41, 0x45,0x45, 0x4b,0x4b, 0x31,0x31} // 0x33 3
  ,{0x18,0x18, 0x14,0x14, 0x12,0x12, 0x7f,0x7f, 0x10,0x10} // 0x34 4
  ,{0x27,0x27, 0x45,0x45, 0x45,0x45, 0x45,0x45, 0x39,0x39} // 0x35 5
  ,{0x3c,0x3c, 0x4a,0x4a, 0x49,0x49, 0x49,0x49, 0x30,0x30} // 0x36 6
  ,{0x01,0x01, 0x71,0x71, 0x09,0x09, 0x05,0x05, 0x03,0x03} // 0x37 7
  ,{0x36,0x36, 0x49,0x49, 0x49,0x49, 0x49,0x49, 0x36,0x36} // 0x38 8
  ,{0x06,0x06, 0x49,0x49, 0x49,0x49, 0x29,0x29, 0x1e,0x1e} // 0x39 9
  ,{0x00,0x00, 0x36,0x36, 0x36,0x36, 0x00,0x00, 0x00,0x00} // 0x3a :
  ,{0x00,0x00, 0x56,0x56, 0x36,0x36, 0x00,0x00, 0x00,0x00} // 0x3b ;
  ,{0x08,0x08, 0x14,0x14, 0x22,0x22, 0x41,0x41, 0x00,0x00} // 0x3c <
  ,{0x14,0x14, 0x14,0x14, 0x14,0x14, 0x14,0x14, 0x14,0x14} // 0x3d =
  ,{0x00,0x00, 0x41,0x41, 0x22,0x22, 0x14,0x14, 0x08,0x08} // 0x3e >
  ,{0x02,0x02, 0x01,0x01, 0x51,0x51, 0x09,0x09, 0x06,0x06} // 0x3f ?
  ,{0x32,0x32, 0x49,0x49, 0x79,0x79, 0x41,0x41, 0x3e,0x3e} // 0x40 @
  ,{0x7e,0x7e, 0x11,0x11, 0x11,0x11, 0x11,0x11, 0x7e,0x7e} // 0x41 A
  ,{0x7f,0x7f, 0x49,0x49, 0x49,0x49, 0x49,0x49, 0x36,0x36} // 0x42 B
  ,{0x3e,0x3e, 0x41,0x41, 0x41,0x41, 0x41,0x41, 0x22,0x22} // 0x43 C
  ,{0x7f,0x7f, 0x41,0x41, 0x41,0x41, 0x22,0x22, 0x1c,0x1c} // 0x44 D
  ,{0x7f,0x7f, 0x49,0x49, 0x49,0x49, 0x49,0x49, 0x41,0x41} // 0x45 E
  ,{0x7f,0x7f, 0x09,0x09, 0x09,0x09, 0x09,0x09, 0x01,0x01} // 0x46 F
  ,{0x3e,0x3e, 0x41,0x41, 0x49,0x49, 0x49,0x49, 0x7a,0x7a} // 0x47 G
  ,{0x7f,0x7f, 0x08,0x08, 0x08,0x08, 0x08,0x08, 0x7f,0x7f} // 0x48 H
  ,{0x00,0x00, 0x41,0x41, 0x7f,0x7f, 0x41,0x41, 0x00,0x00} // 0x49 I
  ,{0x20,0x20, 0x40,0x40, 0x41,0x41, 0x3f,0x3f, 0x01,0x01} // 0x4a J
  ,{0x7f,0x7f, 0x08,0x08, 0x14,0x14, 0x22,0x22, 0x41,0x41} // 0x4b K
  ,{0x7f,0x7f, 0x40,0x40, 0x40,0x40, 0x40,0x40, 0x40,0x40} // 0x4c L
  ,{0x7f,0x7f, 0x02,0x02, 0x0c,0x0c, 0x02,0x02, 0x7f,0x7f} // 0x4d M
  ,{0x7f,0x7f, 0x04,0x04, 0x08,0x08, 0x10,0x10, 0x7f,0x7f} // 0x4e N
  ,{0x3e,0x3e, 0x41,0x41, 0x41,0x41, 0x41,0x41, 0x3e,0x3e} // 0x4f O
  ,{0x7f,0x7f, 0x09,0x09, 0x09,0x09, 0x09,0x09, 0x06,0x06} // 0x50 P
  ,{0x3e,0x3e, 0x41,0x41, 0x51,0x51, 0x21,0x21, 0x5e,0x5e} // 0x51 Q
  ,{0x7f,0x7f, 0x09,0x09, 0x19,0x19, 0x29,0x29, 0x46,0x46} // 0x52 R
  ,{0x46,0x46, 0x49,0x49, 0x49,0x49, 0x49,0x49, 0x31,0x31} // 0x53 S
  ,{0x01,0x01, 0x01,0x01, 0x7f,0x7f, 0x01,0x01, 0x01,0x01} // 0x54 T
  ,{0x3f,0x3f, 0x40,0x40, 0x40,0x40, 0x40,0x40, 0x3f,0x3f} // 0x55 U
  ,{0x1f,0x1f, 0x20,0x20, 0x40,0x40, 0x20,0x20, 0x1f,0x1f} // 0x56 V
  ,{0x3f,0x3f, 0x40,0x40, 0x38,0x38, 0x40,0x40, 0x3f,0x3f} // 0x57 W
  ,{0x63,0x63, 0x14,0x14, 0x08,0x08, 0x14,0x14, 0x63,0x63} // 0x58 X
  ,{0x07,0x07, 0x08,0x08, 0x70,0x70, 0x08,0x08, 0x07,0x07} // 0x59 Y
  ,{0x61,0x61, 0x51,0x51, 0x49,0x49, 0x45,0x45, 0x43,0x43} // 0x5a Z
  ,{0x00,0x00, 0x7f,0x7f, 0x41,0x41, 0x41,0x41, 0x00,0x00} // 0x5b [
  ,{0x02,0x02, 0x04,0x04, 0x08,0x08, 0x10,0x10, 0x20,0x20} // 0x5c \ (keep this to escape the backslash)
  ,{0x00,0x00, 0x41,0x41, 0x41,0x41, 0x7f,0x7f, 0x00,0x00} // 0x5d ]
  ,{0x04,0x04, 0x02,0x02, 0x01,0x01, 0x02,0x02, 0x04,0x04} // 0x5e ^
  ,{0x40,0x40, 0x40,0x40, 0x40,0x40, 0x40,0x40, 0x40,0x40} // 0x5f _
  ,{0x00,0x00, 0x01,0x01, 0x02,0x02, 0x04,0x04, 0x00,0x00} // 0x60 `
  ,{0x20,0x20, 0x54,0x54, 0x54,0x54, 0x54,0x54, 0x78,0x78} // 0x61 a
  ,{0x7f,0x7f, 0x48,0x48, 0x44,0x44, 0x44,0x44, 0x38,0x38} // 0x62 b
  ,{0x38,0x38, 0x44,0x44, 0x44,0x44, 0x44,0x44, 0x20,0x20} // 0x63 c
  ,{0x38,0x38, 0x44,0x44, 0x44,0x44, 0x48,0x48, 0x7f,0x7f} // 0x64 d
  ,{0x38,0x38, 0x54,0x54, 0x54,0x54, 0x54,0x54, 0x18,0x18} // 0x65 e
  ,{0x08,0x08, 0x7e,0x7e, 0x09,0x09, 0x01,0x01, 0x02,0x02} // 0x66 f
  ,{0x0c,0x0c, 0x52,0x52, 0x52,0x52, 0x52,0x52, 0x3e,0x3e} // 0x67 g
  ,{0x7f,0x7f, 0x08,0x08, 0x04,0x04, 0x04,0x04, 0x78,0x78} // 0x68 h
  ,{0x00,0x00, 0x44,0x44, 0x7d,0x7d, 0x40,0x40, 0x00,0x00} // 0x69 i
  ,{0x20,0x20, 0x40,0x40, 0x44,0x44, 0x3d,0x3d, 0x00,0x00} // 0x6a j
  ,{0x7f,0x7f, 0x10,0x10, 0x28,0x28, 0x44,0x44, 0x00,0x00} // 0x6b k
  ,{0x00,0x00, 0x41,0x41, 0x7f,0x7f, 0x40,0x40, 0x00,0x00} // 0x6c l
  ,{0x7c,0x7c, 0x04,0x04, 0x18,0x18, 0x04,0x04, 0x78,0x78} // 0x6d m
  ,{0x7c,0x7c, 0x08,0x08, 0x04,0x04, 0x04,0x04, 0x78,0x78} // 0x6e n
  ,{0x38,0x38, 0x44,0x44, 0x44,0x44, 0x44,0x44, 0x38,0x38} // 0x6f o
  ,{0x7c,0x7c, 0x14,0x14, 0x14,0x14, 0x14,0x14, 0x08,0x08} // 0x70 p
  ,{0x08,0x08, 0x14,0x14, 0x14,0x14, 0x18,0x18, 0x7c,0x7c} // 0x71 q
  ,{0x7c,0x7c, 0x08,0x08, 0x04,0x04, 0x04,0x04, 0x08,0x08} // 0x72 r
  ,{0x48,0x48, 0x54,0x54, 0x54,0x54, 0x54,0x54, 0x20,0x20} // 0x73 s
  ,{0x04,0x04, 0x3f,0x3f, 0x44,0x44, 0x40,0x40, 0x20,0x20} // 0x74 t
  ,{0x3c,0x3c, 0x40,0x40, 0x40,0x40, 0x20,0x20, 0x7c,0x7c} // 0x75 u
  ,{0x1c,0x1c, 0x20,0x20, 0x40,0x40, 0x20,0x20, 0x1c,0x1c} // 0x76 v
  ,{0x3c,0x3c, 0x40,0x40, 0x30,0x30, 0x40,0x40, 0x3c,0x3c} // 0x77 w
  ,{0x44,0x44, 0x28,0x28, 0x10,0x10, 0x28,0x28, 0x44,0x44} // 0x78 x
  ,{0x0c,0x0c, 0x50,0x50, 0x50,0x50, 0x50,0x50, 0x3c,0x3c} // 0x79 y
  ,{0x44,0x44, 0x64,0x64, 0x54,0x54, 0x4c,0x4c, 0x44,0x44} // 0x7a z
  ,{0x00,0x00, 0x08,0x08, 0x36,0x36, 0x41,0x41, 0x00,0x00} // 0x7b {
  ,{0x00,0x00, 0x00,0x00, 0x7f,0x7f, 0x00,0x00, 0x00,0x00} // 0x7c |
  ,{0x00,0x00, 0x41,0x41, 0x36,0x36, 0x08,0x08, 0x00,0x00} // 0x7d }
  ,{0x10,0x10, 0x08,0x08, 0x08,0x08, 0x10,0x10, 0x08,0x08} // 0x7e ~
  ,{0x78,0x78, 0x46,0x46, 0x41,0x41, 0x46,0x46, 0x78,0x78} // 0x7f DEL
};
#endif

void nokia5110_init(void)
{
    // original bias = 0x12 , vop = 0xb3
    gpio_config_pin(LCD_BASE, RST, OUTPUT);
    gpio_config_pin(LCD_BASE, DC, OUTPUT);
    gpio_put_pin(LCD_BASE, RST, HIGH);
    gpio_put_pin(LCD_BASE, DC, HIGH);
    gpio_put_pin(LCD_BASE, RST, LOW);
    gpio_put_pin(LCD_BASE, RST, HIGH);

    spi_init();
    gu8xLoc = 0;
    gu8yLoc = 0;
    nokia5110_put(LCD_COMMAND, 0x21);  // LCD extended commands
    nokia5110_put(LCD_COMMAND, 0xB3);  // set LCD Vop (contrast)
    nokia5110_put(LCD_COMMAND, 0x04);  // set temp coefficent
    nokia5110_put(LCD_COMMAND, 0x12);  // LCD bias mode 1:48
    nokia5110_put(LCD_COMMAND, 0x20);  // LCD basic commands
    nokia5110_put(LCD_COMMAND, 0x0C);  // LCD normal mode
    nokia5110_go_xy(0,0);
}


void nokia5110_test(void)
{
    nokia5110_put(LCD_COMMAND, 0x20);  // LCD basic commands
    nokia5110_put(LCD_COMMAND, 0x09);  // turn all segments on
}

void nokia5110_put(uint8_t command_or_data, const uint8_t __data)
{
    (command_or_data) ? (gpio_put_pin(LCD_BASE, DC, HIGH)) : (gpio_put_pin(LCD_BASE, DC, LOW)); 
    spi_setSS1();
    spi_put(__data); //transmit serial data
    spi_clearSS1();
    gu8xLoc++;
    if(gu8xLoc >= 84)  // avoid 83 so when the cursor has just moved to the next row instead of leaving it empty if NEW_LINE is used
    {
        gu8xLoc = 0;
        gu8yLoc++;
    }
    gu8yLoc = gu8yLoc % 6;
}

// TODO: add a code to update the buffer with this function
// NOTE: this limits the no. of chars per line, normal font 14 chars(each 5 pixels) + 14 single pixels = 84 total pixels
// for bold font 7 char(each 10 pixels) + 14 single pixels = 84 total pixels
// this is done this way to avoid having chars showing half of it on one line and the rest on another line
void nokia5110_put_char(uint8_t __character)
{
    uint8_t column;
    if (__character == NEW_LINE || __character == ENTER || __character == RETURN)
    {
        for (uint8_t i = 0; i < 84-gu8xLoc; i++)
        {
            mapArray[(gu8xLoc + (gu8yLoc*LCD_WIDTH))+i] = 0x00;
        }
        nokia5110_go_xy(0, ++gu8yLoc);
        return ;
    } 
    #ifndef __USE_BOLD_FONT
        for (uint8_t i = 0; i < 5; i++)
        {
            column = pgm_read_byte(&ASCII[__character - 0x20][i]);
            mapArray[gu8xLoc + (gu8yLoc*LCD_WIDTH)] = column;
            nokia5110_put(LCD_DATA, column);
        }
        mapArray[gu8xLoc + (gu8yLoc*LCD_WIDTH)] = 0x00;
        nokia5110_put(LCD_DATA, 0x00);        // SMALL space between characters
    #else
        for (uint8_t i = 0; i < 10; i++)
        {
            column = pgm_read_byte(&ASCII[__character - 0x20][i]);
            nokia5110_put(LCD_DATA,  column);
        } 
        nokia5110_put(LCD_DATA, 0x00);        // SMALL space between characters
        nokia5110_put(LCD_DATA, 0x00);        // SMALL space between characters
    #endif
}

// this draws characters as a bitmap so it doesnt keep track of x,y locations
// This function will draw a char at a defined x and y).
// The color can be either black (1) or white (0).
// this has the advantage over put_char() that we can keep track of the display when using characters
// also you can put characters in non-stand places
void nokia5110_set_char(char character, uint8_t y, uint8_t x, uint8_t bw)
{
    uint8_t column;           // temp byte to store character's column bitmap
    //column = character;
    for (uint8_t i = 0; i < 5; i++)   // 5 columns (x) per character
    {
        column = pgm_read_byte(&ASCII[character - 0x20][i]);
        for (uint8_t j = 0; j < 8; j++) // 8 rows (y) per character
        {
            if (column & (0x01 << j)) nokia5110_pixel(y+j, x+i, bw);
            else
            {
                nokia5110_pixel(y+j, x+i, !bw);
            }
        }
    }
}


void nokia5110_put_string(char *str_ptr)
{
    for ( ; *str_ptr; str_ptr++) nokia5110_put_char(*str_ptr);
}


// this draws a string of characters as a bitmap
void nokia5110_set_string(char * dString, uint8_t y, uint8_t x, uint8_t bw)
{
  while (*dString != 0x00) // loop until null terminator
  {
    nokia5110_set_char(*dString++, y, x, bw);
    x += 5;
    // do the white spacing
    for (uint8_t i = y; i < (y + 8); i++)
    {
      nokia5110_pixel(i, x, !bw);
    }
    x++;
    if (x > (LCD_WIDTH - 5)) // Enables wrap around
    {
      x = 0;
      y += 8;
    }
  }
}

void nokia5110_clear_display(void)
{
    for (int i=0; i < (LCD_WIDTH * LCD_HEIGHT >> 3); i++)
    {
        mapArray[i] = 0x00;
        nokia5110_put(LCD_DATA, 0x00);
    }
    nokia5110_go_xy(0,0);
    gu8xLoc = 0;
    gu8yLoc = 0;
}

// y = 0 : 5 , x = 0 : 83
void nokia5110_go_xy(uint8_t y, uint8_t x)
{
    if (x >= 0 && x <= 83 && y >= 0 && y <= 5)
    {
        nokia5110_put(LCD_COMMAND, 0x40 | y);  // row
        nokia5110_put(LCD_COMMAND, 0x80 | x);  // col
        gu8xLoc = x;
        gu8yLoc = y;
    }
}

// Set contrast can set the LCD Vop to a value between 0 and 127.
// 40-60 is usually a pretty good range.
void nokia5110_set_contrast(uint8_t contrast)
{
    nokia5110_put(LCD_COMMAND, 0x21); //Tell LCD that extended commands follow
    nokia5110_put(LCD_COMMAND, 0x80 | contrast); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
    nokia5110_put(LCD_COMMAND, 0x20); //Set display mode
}


void nokia5110_invert_display(void)
{
    static uint8_t counter = 0;
    counter++;
    nokia5110_put(LCD_COMMAND, 0x20); //Tell LCD that extended commands follow
    if ((counter = counter % 2))    nokia5110_put(LCD_COMMAND, 0x0D); // inverse mode
    else nokia5110_put(LCD_COMMAND, 0x0C); // normal mode
}

void nokia5110_invert_bitmap(void)
{
    for (uint16_t i = 0; i < 504; i++)
    {
        mapArray[i] = ~mapArray[i] & 0xFF;
    }
}

// This will actually draw on the display, whatever is currently
// in the bitmap array.
void nokia5110_disp_bitmap(const uint8_t *arrayPtr)
{
    //nokia5110_goxy(0,0);      // to enable making the image shift to right/left
    nokia5110_set_bitmap(arrayPtr);
    nokia5110_update_display();
}

void nokia5110_update_display(void)
{
    uint8_t yflag = 0, xflag = 0 , xpos = 0;
    xpos = gu8xLoc;
    
    if (gu8xLoc != 0 && yflag == 0)
    {
        yflag = 1;
    }
    for (uint16_t i = 0; i < 504; i++)
    {
        // this is to avoid when the screen addresses are over it wont overwrite from the start
        if (yflag && gu8xLoc == 0 && gu8yLoc == 0)
        {
            gu8yLoc = 5;
            yflag = 0;
            xflag = 0;
        }  
        if (yflag && gu8yLoc >= 1 && gu8xLoc == 0)
        {
            gu8yLoc = gu8yLoc - 1;
            yflag = 0;
            xflag = 1;
        }
        if (xflag && gu8xLoc == xpos)
        {
            gu8yLoc = gu8yLoc + 1;
            yflag = 1;
            xflag = 0;
        }
        nokia5110_go_xy(gu8yLoc,gu8xLoc);
        nokia5110_put(LCD_DATA, mapArray[i]);
    }
}

// TODO: not finished
// this updates only a specific part of the display such as after set_char() we only need to update small portion of the screen
void nokia5110_partialUpdate_display(uint8_t y0, uint8_t x0, uint8_t y1, uint8_t x1)
{
    uint8_t i;
    uint8_t j;

    nokia5110_go_xy(y0>>3, x0);
    for (i = y0; i <= y1; i++)
    {
        for (j = x0; j <= x1; j++)
        {
            nokia5110_put(LCD_DATA, mapArray[i*j]);
        }
    }
}

// this copies the bitmap array from flash into mapArray in ram
void nokia5110_set_bitmap(const uint8_t *arrayPtr)
{
    for (uint16_t i = 0; i < 504; i++)
    {
        uint8_t c = pgm_read_byte(&arrayPtr[i]);
        mapArray[i] = c;
    }  
}


// This function sets a pixel on mapArray to your preferred
// color. 1=Black, 0= white.
void nokia5110_pixel(uint8_t y, uint8_t x, uint8_t bw)
{
    // First, double check that the coordinate is in range.
    if ((x >= 0) && (x < LCD_WIDTH) && (y >= 0) && (y < LCD_HEIGHT))
    {
        uint8_t shift = y % 8;

        if (bw) // If black, set the bit.
            mapArray[x + (y>>3)*LCD_WIDTH] |= 1<<shift;
        else   // If white clear the bit.
            mapArray[x + (y>>3)*LCD_WIDTH] &= ~(1<<shift);
    }
}

void nokia5110_set_pixel(uint8_t y, uint8_t x)
{
    nokia5110_pixel(y, x, BLACK); // Call setPixel with bw set to Black
}

void nokia5110_clear_pixel(uint8_t y, uint8_t x)
{
    nokia5110_pixel(y, x, WHITE); // call setPixel with bw set to white
}

uint8_t nokia5110_get_pixel(uint8_t y, uint8_t x)
{
    if ((x >= LCD_WIDTH) || (y >= LCD_HEIGHT))
        return 0;

    return (mapArray[x+ (y >> 3)*LCD_WIDTH] >> (7-(y%8))) & 0x1;  
}

/*
// this doesnt touch the buffer, just clears the display RAM - might be handy
void PCD8544::clearDisplay(void) {
  
  uint8_t p, c;
  
  for(p = 0; p < 8; p++) {
    st7565_command(CMD_SET_PAGE | p);
    for(c = 0; c < 129; c++) {
      //uart_putw_dec(c);
      //uart_putchar(' ');
      st7565_command(CMD_SET_COLUMN_LOWER | (c & 0xf));
      st7565_command(CMD_SET_COLUMN_UPPER | ((c >> 4) & 0xf));
      st7565_data(0x0);
    }     
    }
}
*/
