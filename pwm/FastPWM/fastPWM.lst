   1               		.file	"fastPWM.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	fastPWM0_init
  12               	fastPWM0_init:
  13               	.LFB0:
  14               		.file 1 "pwm/FastPWM/fastPWM.c"
   1:pwm/FastPWM/fastPWM.c **** #include "fastPWM.h"
   2:pwm/FastPWM/fastPWM.c **** 
   3:pwm/FastPWM/fastPWM.c **** // timer 0
   4:pwm/FastPWM/fastPWM.c **** void fastPWM0_init(uint32_t freq)
   5:pwm/FastPWM/fastPWM.c **** {
  15               		.loc 1 5 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
   6:pwm/FastPWM/fastPWM.c **** 	// this routine works with non-inverted mode only
   7:pwm/FastPWM/fastPWM.c **** 	uint16_t prescaler = 0;
   8:pwm/FastPWM/fastPWM.c **** 	// freq can be from 617222 hz with pre = 1 : 61 hz with pre = 1024
   9:pwm/FastPWM/fastPWM.c **** 
  10:pwm/FastPWM/fastPWM.c **** 	// select prescaler with the min. possible error margin
  11:pwm/FastPWM/fastPWM.c **** 	// freq = F_CPU / (256*Prescaler)
  12:pwm/FastPWM/fastPWM.c **** 	// for default value set the freq argument with the value 0
  13:pwm/FastPWM/fastPWM.c **** 	if(freq == 0){
  22               		.loc 1 13 0
  23 0000 6115      		cp r22,__zero_reg__
  24 0002 7105      		cpc r23,__zero_reg__
  25 0004 8105      		cpc r24,__zero_reg__
  26 0006 9105      		cpc r25,__zero_reg__
  27 0008 01F0      		breq .L2
  14:pwm/FastPWM/fastPWM.c **** 		prescaler = 1;
  15:pwm/FastPWM/fastPWM.c **** 	}
  16:pwm/FastPWM/fastPWM.c **** 	else
  17:pwm/FastPWM/fastPWM.c **** 	{
  18:pwm/FastPWM/fastPWM.c **** 		prescaler = F_CPU / (freq * 256);
  28               		.loc 1 18 0
  29 000a 2227      		clr r18
  30 000c 362F      		mov r19,r22
  31 000e 472F      		mov r20,r23
  32 0010 582F      		mov r21,r24
  33 0012 60E0      		ldi r22,0
  34 0014 74E2      		ldi r23,lo8(36)
  35 0016 84EF      		ldi r24,lo8(-12)
  36 0018 90E0      		ldi r25,0
  37               	.LVL1:
  38 001a 0E94 0000 		call __udivmodsi4
  39               	.LVL2:
  19:pwm/FastPWM/fastPWM.c **** 		if(prescaler < 1)	prescaler = 1;
  40               		.loc 1 19 0
  41 001e 2530      		cpi r18,5
  42 0020 3105      		cpc r19,__zero_reg__
  43 0022 00F0      		brlo .L2
  20:pwm/FastPWM/fastPWM.c **** 		else if(prescaler >= 1 && prescaler <= 4)	prescaler = 1;
  21:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 4 && prescaler <= 36)	prescaler = 8;
  44               		.loc 1 21 0
  45 0024 C901      		movw r24,r18
  46 0026 0597      		sbiw r24,5
  47 0028 8032      		cpi r24,32
  48 002a 9105      		cpc r25,__zero_reg__
  49 002c 00F0      		brlo .L3
  22:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 36 && prescaler <= 160)	prescaler = 64;
  50               		.loc 1 22 0
  51 002e 8097      		sbiw r24,32
  52 0030 8C37      		cpi r24,124
  53 0032 9105      		cpc r25,__zero_reg__
  54 0034 00F0      		brlo .L4
  23:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 160 && prescaler <= 640)	prescaler = 256;
  55               		.loc 1 23 0
  56 0036 215A      		subi r18,-95
  57 0038 3109      		sbc r19,__zero_reg__
  58               	.LVL3:
  59 003a 203E      		cpi r18,-32
  60 003c 3140      		sbci r19,1
  61 003e 00F4      		brsh .L17
  62               	.LVL4:
  24:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 640 && prescaler <= 1024)	prescaler = 1024;
  25:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 1024)	prescaler = 1024;
  26:pwm/FastPWM/fastPWM.c **** 	}
  27:pwm/FastPWM/fastPWM.c **** 	// FIXME : should make TCCR0 = not with | as changing the freq would cause error
  28:pwm/FastPWM/fastPWM.c **** 	// set the prescaler in the register
  29:pwm/FastPWM/fastPWM.c **** 	switch(prescaler)
  30:pwm/FastPWM/fastPWM.c **** 	{
  31:pwm/FastPWM/fastPWM.c **** 		case 1:
  32:pwm/FastPWM/fastPWM.c **** 			TCCR0 |= (1<<0) | (1<<3) | (1<<6) | (1<<5);
  33:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<1);
  34:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<2);
  35:pwm/FastPWM/fastPWM.c **** 			break;
  36:pwm/FastPWM/fastPWM.c **** 		case 8:
  37:pwm/FastPWM/fastPWM.c **** 			TCCR0 |= (1<<1) | (1<<3) | (1<<6) | (1<<5);
  38:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<0);
  39:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<2);
  40:pwm/FastPWM/fastPWM.c **** 			break;
  41:pwm/FastPWM/fastPWM.c **** 		case 64:
  42:pwm/FastPWM/fastPWM.c **** 			TCCR0 |= (1<<0) | (1<<1) | (1<<3) | (1<<6) | (1<<5);
  43:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<2);
  44:pwm/FastPWM/fastPWM.c **** 			break;
  45:pwm/FastPWM/fastPWM.c **** 		case 256:
  46:pwm/FastPWM/fastPWM.c **** 			TCCR0 |= (1<<2) | (1<<3) | (1<<6) | (1<<5);
  63               		.loc 1 46 0
  64 0040 83B7      		in r24,0x33
  65 0042 8C66      		ori r24,lo8(108)
  66 0044 83BF      		out 0x33,r24
  47:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<0);
  67               		.loc 1 47 0
  68 0046 83B7      		in r24,0x33
  69 0048 8E7F      		andi r24,lo8(-2)
  70 004a 00C0      		rjmp .L15
  71               	.LVL5:
  72               	.L4:
  42:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<2);
  73               		.loc 1 42 0
  74 004c 83B7      		in r24,0x33
  75 004e 8B66      		ori r24,lo8(107)
  76 0050 00C0      		rjmp .L14
  77               	.LVL6:
  78               	.L17:
  48:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<1);
  49:pwm/FastPWM/fastPWM.c **** 			break;
  50:pwm/FastPWM/fastPWM.c **** 		case 1024:
  51:pwm/FastPWM/fastPWM.c **** 			TCCR0 |= (1<<0) | (1<<2) | (1<<3) | (1<<6) | (1<<5);
  79               		.loc 1 51 0
  80 0052 83B7      		in r24,0x33
  81 0054 8D66      		ori r24,lo8(109)
  82               	.LVL7:
  83               	.L15:
  84 0056 83BF      		out 0x33,r24
  52:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<1);
  85               		.loc 1 52 0
  86 0058 83B7      		in r24,0x33
  87 005a 8D7F      		andi r24,lo8(-3)
  88 005c 00C0      		rjmp .L13
  89               	.L2:
  90               	.LVL8:
  32:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<1);
  91               		.loc 1 32 0
  92 005e 83B7      		in r24,0x33
  93 0060 8966      		ori r24,lo8(105)
  94 0062 83BF      		out 0x33,r24
  33:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<2);
  95               		.loc 1 33 0
  96 0064 83B7      		in r24,0x33
  97 0066 8D7F      		andi r24,lo8(-3)
  98               	.LVL9:
  99               	.L14:
 100 0068 83BF      		out 0x33,r24
  34:pwm/FastPWM/fastPWM.c **** 			break;
 101               		.loc 1 34 0
 102 006a 83B7      		in r24,0x33
 103 006c 8B7F      		andi r24,lo8(-5)
 104               	.L13:
 105 006e 83BF      		out 0x33,r24
  53:pwm/FastPWM/fastPWM.c **** 			break;
  54:pwm/FastPWM/fastPWM.c **** 		default:
  55:pwm/FastPWM/fastPWM.c **** 			TCCR0 |= (1<<0) | (1<<3) | (1<<6) | (1<<5);
  56:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<1);
  57:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<2);
  58:pwm/FastPWM/fastPWM.c **** 			break;
  59:pwm/FastPWM/fastPWM.c **** 	}
  60:pwm/FastPWM/fastPWM.c **** 
  61:pwm/FastPWM/fastPWM.c **** 	// pb3 must be set output ( oc0 )
  62:pwm/FastPWM/fastPWM.c **** 	DDRB |= (1<<PWM0);
 106               		.loc 1 62 0
 107 0070 BB9A      		sbi 0x17,3
  63:pwm/FastPWM/fastPWM.c **** 	// init TCNT0 to 0
  64:pwm/FastPWM/fastPWM.c **** 	TCNT0 = 0;
 108               		.loc 1 64 0
 109 0072 12BE      		out 0x32,__zero_reg__
 110 0074 0895      		ret
 111               	.LVL10:
 112               	.L3:
  37:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<0);
 113               		.loc 1 37 0
 114 0076 83B7      		in r24,0x33
 115 0078 8A66      		ori r24,lo8(106)
 116 007a 83BF      		out 0x33,r24
  38:pwm/FastPWM/fastPWM.c **** 			TCCR0 &= ~(1<<2);
 117               		.loc 1 38 0
 118 007c 83B7      		in r24,0x33
 119 007e 8E7F      		andi r24,lo8(-2)
 120 0080 00C0      		rjmp .L14
 121               		.cfi_endproc
 122               	.LFE0:
 124               	.global	fastPWM0_stop
 126               	fastPWM0_stop:
 127               	.LFB2:
  65:pwm/FastPWM/fastPWM.c **** }
  66:pwm/FastPWM/fastPWM.c **** 
  67:pwm/FastPWM/fastPWM.c **** void fastPWM0_duty(uint8_t duty)
  68:pwm/FastPWM/fastPWM.c **** {
  69:pwm/FastPWM/fastPWM.c **** 	// so when pwmstop occurs it can call back pwm function without init again
  70:pwm/FastPWM/fastPWM.c **** 	TCCR0 |= (1<<5);
  71:pwm/FastPWM/fastPWM.c **** 	if(duty == 0)	fastPWM0_stop();
  72:pwm/FastPWM/fastPWM.c **** 	else	OCR0 = ((duty * 256) / 100) - 1;
  73:pwm/FastPWM/fastPWM.c **** }
  74:pwm/FastPWM/fastPWM.c **** 
  75:pwm/FastPWM/fastPWM.c **** void fastPWM0_stop(void)
  76:pwm/FastPWM/fastPWM.c **** {
 128               		.loc 1 76 0
 129               		.cfi_startproc
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 0 */
 133               	.L__stack_usage = 0
  77:pwm/FastPWM/fastPWM.c **** 	// notice this way you stop timer 0 from all opertaions and when you come back you have to reiniti
  78:pwm/FastPWM/fastPWM.c **** 	//TCCR0 = 0;
  79:pwm/FastPWM/fastPWM.c **** 
  80:pwm/FastPWM/fastPWM.c **** 	// this way you dont stop the timer so you wont need to reinit
  81:pwm/FastPWM/fastPWM.c **** 	OCR0 = 0;
 134               		.loc 1 81 0
 135 0082 1CBE      		out 0x3c,__zero_reg__
  82:pwm/FastPWM/fastPWM.c **** 	TCNT0 = 0;
 136               		.loc 1 82 0
 137 0084 12BE      		out 0x32,__zero_reg__
  83:pwm/FastPWM/fastPWM.c **** 	// oc0 pin diconnected, normal port operation
  84:pwm/FastPWM/fastPWM.c **** 	TCCR0 &= ~(1<<4);
 138               		.loc 1 84 0
 139 0086 83B7      		in r24,0x33
 140 0088 8F7E      		andi r24,lo8(-17)
 141 008a 83BF      		out 0x33,r24
  85:pwm/FastPWM/fastPWM.c **** 	TCCR0 &= ~(1<<5);
 142               		.loc 1 85 0
 143 008c 83B7      		in r24,0x33
 144 008e 8F7D      		andi r24,lo8(-33)
 145 0090 83BF      		out 0x33,r24
 146 0092 0895      		ret
 147               		.cfi_endproc
 148               	.LFE2:
 150               	.global	fastPWM0_duty
 152               	fastPWM0_duty:
 153               	.LFB1:
  68:pwm/FastPWM/fastPWM.c **** 	// so when pwmstop occurs it can call back pwm function without init again
 154               		.loc 1 68 0
 155               		.cfi_startproc
 156               	.LVL11:
 157               	/* prologue: function */
 158               	/* frame size = 0 */
 159               	/* stack size = 0 */
 160               	.L__stack_usage = 0
  70:pwm/FastPWM/fastPWM.c **** 	if(duty == 0)	fastPWM0_stop();
 161               		.loc 1 70 0
 162 0094 93B7      		in r25,0x33
 163 0096 9062      		ori r25,lo8(32)
 164 0098 93BF      		out 0x33,r25
  71:pwm/FastPWM/fastPWM.c **** 	else	OCR0 = ((duty * 256) / 100) - 1;
 165               		.loc 1 71 0
 166 009a 8111      		cpse r24,__zero_reg__
 167 009c 00C0      		rjmp .L20
  71:pwm/FastPWM/fastPWM.c **** 	else	OCR0 = ((duty * 256) / 100) - 1;
 168               		.loc 1 71 0 is_stmt 0 discriminator 1
 169 009e 0C94 0000 		jmp fastPWM0_stop
 170               	.LVL12:
 171               	.L20:
  72:pwm/FastPWM/fastPWM.c **** }
 172               		.loc 1 72 0 is_stmt 1
 173 00a2 982F      		mov r25,r24
 174 00a4 80E0      		ldi r24,0
 175               	.LVL13:
 176 00a6 64E6      		ldi r22,lo8(100)
 177 00a8 70E0      		ldi r23,0
 178 00aa 0E94 0000 		call __divmodhi4
 179 00ae 6150      		subi r22,lo8(-(-1))
 180 00b0 6CBF      		out 0x3c,r22
 181 00b2 0895      		ret
 182               		.cfi_endproc
 183               	.LFE1:
 185               	.global	fastPWM2_init
 187               	fastPWM2_init:
 188               	.LFB3:
  86:pwm/FastPWM/fastPWM.c **** }
  87:pwm/FastPWM/fastPWM.c **** 
  88:pwm/FastPWM/fastPWM.c **** /***********************************************************************/
  89:pwm/FastPWM/fastPWM.c **** // timer 2
  90:pwm/FastPWM/fastPWM.c **** 
  91:pwm/FastPWM/fastPWM.c **** void fastPWM2_init(uint32_t freq)
  92:pwm/FastPWM/fastPWM.c **** {
 189               		.loc 1 92 0
 190               		.cfi_startproc
 191               	.LVL14:
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 0 */
 195               	.L__stack_usage = 0
  93:pwm/FastPWM/fastPWM.c **** 	// this routine works with non-inverted mode only
  94:pwm/FastPWM/fastPWM.c **** 	uint16_t prescaler = 0;
  95:pwm/FastPWM/fastPWM.c **** 	// freq can be from 617222 hz with pre = 1 : 61 hz with pre = 1024
  96:pwm/FastPWM/fastPWM.c **** 
  97:pwm/FastPWM/fastPWM.c **** 	// select prescaler with the min. possible error margin
  98:pwm/FastPWM/fastPWM.c **** 	// freq = F_CPU / (256*Prescaler)
  99:pwm/FastPWM/fastPWM.c **** 	// for default value set the freq argument with the value 0
 100:pwm/FastPWM/fastPWM.c **** 	if(freq == 0){
 196               		.loc 1 100 0
 197 00b4 6115      		cp r22,__zero_reg__
 198 00b6 7105      		cpc r23,__zero_reg__
 199 00b8 8105      		cpc r24,__zero_reg__
 200 00ba 9105      		cpc r25,__zero_reg__
 201 00bc 01F0      		breq .L22
 101:pwm/FastPWM/fastPWM.c **** 		prescaler = 1;
 102:pwm/FastPWM/fastPWM.c **** 	}
 103:pwm/FastPWM/fastPWM.c **** 	else
 104:pwm/FastPWM/fastPWM.c **** 	{
 105:pwm/FastPWM/fastPWM.c **** 		prescaler = F_CPU / (freq * 256);
 202               		.loc 1 105 0
 203 00be 2227      		clr r18
 204 00c0 362F      		mov r19,r22
 205 00c2 472F      		mov r20,r23
 206 00c4 582F      		mov r21,r24
 207 00c6 60E0      		ldi r22,0
 208 00c8 74E2      		ldi r23,lo8(36)
 209 00ca 84EF      		ldi r24,lo8(-12)
 210 00cc 90E0      		ldi r25,0
 211               	.LVL15:
 212 00ce 0E94 0000 		call __udivmodsi4
 213               	.LVL16:
 106:pwm/FastPWM/fastPWM.c **** 		if(prescaler < 1)	prescaler = 1;
 214               		.loc 1 106 0
 215 00d2 2530      		cpi r18,5
 216 00d4 3105      		cpc r19,__zero_reg__
 217 00d6 00F0      		brlo .L22
 107:pwm/FastPWM/fastPWM.c **** 		else if(prescaler >= 1 && prescaler <= 4)	prescaler = 1;
 108:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 4 && prescaler <= 20)	prescaler = 8;
 218               		.loc 1 108 0
 219 00d8 C901      		movw r24,r18
 220 00da 0597      		sbiw r24,5
 221 00dc 8031      		cpi r24,16
 222 00de 9105      		cpc r25,__zero_reg__
 223 00e0 00F0      		brlo .L23
 109:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 20 && prescaler <= 48)	prescaler = 32;
 224               		.loc 1 109 0
 225 00e2 4097      		sbiw r24,16
 226 00e4 8C31      		cpi r24,28
 227 00e6 9105      		cpc r25,__zero_reg__
 228 00e8 00F0      		brlo .L24
 110:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 48 && prescaler <= 96)	prescaler = 64;
 229               		.loc 1 110 0
 230 00ea 4C97      		sbiw r24,28
 231 00ec 8033      		cpi r24,48
 232 00ee 9105      		cpc r25,__zero_reg__
 233 00f0 00F0      		brlo .L25
 111:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 96 && prescaler <= 192)	prescaler = 128;
 234               		.loc 1 111 0
 235 00f2 C097      		sbiw r24,48
 236 00f4 8036      		cpi r24,96
 237 00f6 9105      		cpc r25,__zero_reg__
 238 00f8 00F0      		brlo .L26
 112:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 192 && prescaler <= 640)	prescaler = 256;
 239               		.loc 1 112 0
 240 00fa 215C      		subi r18,-63
 241 00fc 3109      		sbc r19,__zero_reg__
 242               	.LVL17:
 243 00fe 203C      		cpi r18,-64
 244 0100 3140      		sbci r19,1
 245 0102 00F4      		brsh .L38
 246               	.LVL18:
 113:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 640 && prescaler <= 1024)	prescaler = 1024;
 114:pwm/FastPWM/fastPWM.c **** 		else if(prescaler > 1024)	prescaler = 1024;
 115:pwm/FastPWM/fastPWM.c **** 	}
 116:pwm/FastPWM/fastPWM.c **** 
 117:pwm/FastPWM/fastPWM.c **** 	// set the prescaler in the register
 118:pwm/FastPWM/fastPWM.c **** 	switch(prescaler)
 119:pwm/FastPWM/fastPWM.c **** 	{
 120:pwm/FastPWM/fastPWM.c **** 		case 1:
 121:pwm/FastPWM/fastPWM.c **** 			TCCR2 |= (1<<0) | (1<<3) | (1<<6) | (1<<5);
 122:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<1);
 123:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<2);
 124:pwm/FastPWM/fastPWM.c **** 			break;
 125:pwm/FastPWM/fastPWM.c **** 		case 8:
 126:pwm/FastPWM/fastPWM.c **** 			TCCR2 |= (1<<1) | (1<<3) | (1<<6) | (1<<5);
 127:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<0);
 128:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<2);
 129:pwm/FastPWM/fastPWM.c **** 			break;
 130:pwm/FastPWM/fastPWM.c **** 		case 32:
 131:pwm/FastPWM/fastPWM.c **** 			TCCR2 |= (1<<0) | (1<<1) | (1<<3) | (1<<6) | (1<<5);
 132:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<2);
 133:pwm/FastPWM/fastPWM.c **** 			break;
 134:pwm/FastPWM/fastPWM.c **** 		case 64:
 135:pwm/FastPWM/fastPWM.c **** 			TCCR2 |= (1<<2) | (1<<3) | (1<<6) | (1<<5);
 136:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<0);
 137:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<1);
 138:pwm/FastPWM/fastPWM.c **** 			break;
 139:pwm/FastPWM/fastPWM.c **** 		case 128:
 140:pwm/FastPWM/fastPWM.c **** 			TCCR2 |= (1<<0) | (1<<2) | (1<<3) | (1<<6) | (1<<5);
 141:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<1);
 142:pwm/FastPWM/fastPWM.c **** 			break;
 143:pwm/FastPWM/fastPWM.c **** 		case 256:
 144:pwm/FastPWM/fastPWM.c **** 			TCCR2 |= (1<<1) | (1<<2) | (1<<3) | (1<<6) | (1<<5);
 247               		.loc 1 144 0
 248 0104 85B5      		in r24,0x25
 249 0106 8E66      		ori r24,lo8(110)
 250 0108 85BD      		out 0x25,r24
 145:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<0);
 251               		.loc 1 145 0
 252 010a 85B5      		in r24,0x25
 253 010c 8E7F      		andi r24,lo8(-2)
 254 010e 00C0      		rjmp .L35
 255               	.LVL19:
 256               	.L22:
 121:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<1);
 257               		.loc 1 121 0
 258 0110 85B5      		in r24,0x25
 259 0112 8966      		ori r24,lo8(105)
 260 0114 85BD      		out 0x25,r24
 122:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<2);
 261               		.loc 1 122 0
 262 0116 85B5      		in r24,0x25
 263 0118 8D7F      		andi r24,lo8(-3)
 264 011a 00C0      		rjmp .L36
 265               	.LVL20:
 266               	.L23:
 126:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<0);
 267               		.loc 1 126 0
 268 011c 85B5      		in r24,0x25
 269 011e 8A66      		ori r24,lo8(106)
 270 0120 85BD      		out 0x25,r24
 127:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<2);
 271               		.loc 1 127 0
 272 0122 85B5      		in r24,0x25
 273 0124 8E7F      		andi r24,lo8(-2)
 274 0126 00C0      		rjmp .L36
 275               	.LVL21:
 276               	.L24:
 131:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<2);
 277               		.loc 1 131 0
 278 0128 85B5      		in r24,0x25
 279 012a 8B66      		ori r24,lo8(107)
 280               	.LVL22:
 281               	.L36:
 282 012c 85BD      		out 0x25,r24
 132:pwm/FastPWM/fastPWM.c **** 			break;
 283               		.loc 1 132 0
 284 012e 85B5      		in r24,0x25
 285 0130 8B7F      		andi r24,lo8(-5)
 286 0132 00C0      		rjmp .L35
 287               	.LVL23:
 288               	.L25:
 135:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<0);
 289               		.loc 1 135 0
 290 0134 85B5      		in r24,0x25
 291 0136 8C66      		ori r24,lo8(108)
 292 0138 85BD      		out 0x25,r24
 136:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<1);
 293               		.loc 1 136 0
 294 013a 85B5      		in r24,0x25
 295 013c 8E7F      		andi r24,lo8(-2)
 296 013e 00C0      		rjmp .L37
 297               	.LVL24:
 298               	.L26:
 140:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<1);
 299               		.loc 1 140 0
 300 0140 85B5      		in r24,0x25
 301 0142 8D66      		ori r24,lo8(109)
 302               	.LVL25:
 303               	.L37:
 304 0144 85BD      		out 0x25,r24
 141:pwm/FastPWM/fastPWM.c **** 			break;
 305               		.loc 1 141 0
 306 0146 85B5      		in r24,0x25
 307 0148 8D7F      		andi r24,lo8(-3)
 308 014a 00C0      		rjmp .L35
 309               	.LVL26:
 310               	.L38:
 146:pwm/FastPWM/fastPWM.c **** 			break;
 147:pwm/FastPWM/fastPWM.c **** 		case 1024:
 148:pwm/FastPWM/fastPWM.c **** 			TCCR2 |= (1<<0) | (1<<1) | (1<<2) | (1<<3) | (1<<6) | (1<<5);
 311               		.loc 1 148 0
 312 014c 85B5      		in r24,0x25
 313 014e 8F66      		ori r24,lo8(111)
 314               	.LVL27:
 315               	.L35:
 316 0150 85BD      		out 0x25,r24
 149:pwm/FastPWM/fastPWM.c **** 			break;
 150:pwm/FastPWM/fastPWM.c **** 		default:
 151:pwm/FastPWM/fastPWM.c **** 			TCCR2 |= (1<<0) | (1<<3) | (1<<6) | (1<<5);
 152:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<1);
 153:pwm/FastPWM/fastPWM.c **** 			TCCR2 &= ~(1<<2);
 154:pwm/FastPWM/fastPWM.c **** 			break;
 155:pwm/FastPWM/fastPWM.c **** 	}
 156:pwm/FastPWM/fastPWM.c **** 
 157:pwm/FastPWM/fastPWM.c **** 	// pd7 must be set output ( oc2 )
 158:pwm/FastPWM/fastPWM.c **** 	DDRD |= (1<<PWM2);
 317               		.loc 1 158 0
 318 0152 8F9A      		sbi 0x11,7
 159:pwm/FastPWM/fastPWM.c **** 	// init TCNT0 to 0
 160:pwm/FastPWM/fastPWM.c **** 	TCNT2 = 0;
 319               		.loc 1 160 0
 320 0154 14BC      		out 0x24,__zero_reg__
 321 0156 0895      		ret
 322               		.cfi_endproc
 323               	.LFE3:
 325               	.global	fastPWM2_stop
 327               	fastPWM2_stop:
 328               	.LFB5:
 161:pwm/FastPWM/fastPWM.c **** }
 162:pwm/FastPWM/fastPWM.c **** 
 163:pwm/FastPWM/fastPWM.c **** void fastPWM2_duty(uint8_t duty)
 164:pwm/FastPWM/fastPWM.c **** {
 165:pwm/FastPWM/fastPWM.c **** 	// so when pwmstop occurs it can call back pwm function without init again
 166:pwm/FastPWM/fastPWM.c **** 	TCCR2 |= (1<<5);
 167:pwm/FastPWM/fastPWM.c **** 	if(duty == 0)	fastPWM2_stop();
 168:pwm/FastPWM/fastPWM.c **** 	else	OCR2 = ((duty * 256) / 100) - 1;
 169:pwm/FastPWM/fastPWM.c **** }
 170:pwm/FastPWM/fastPWM.c **** 
 171:pwm/FastPWM/fastPWM.c **** void fastPWM2_stop(void)
 172:pwm/FastPWM/fastPWM.c **** {
 329               		.loc 1 172 0
 330               		.cfi_startproc
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333               	/* stack size = 0 */
 334               	.L__stack_usage = 0
 173:pwm/FastPWM/fastPWM.c **** 	// notice this way you stop timer 0 from all opertaions and when you come back you have to reiniti
 174:pwm/FastPWM/fastPWM.c **** 	//TCCR0 = 0;
 175:pwm/FastPWM/fastPWM.c **** 
 176:pwm/FastPWM/fastPWM.c **** 	// this way you dont stop the timer so you wont need to reinit
 177:pwm/FastPWM/fastPWM.c **** 	OCR2 = 0;
 335               		.loc 1 177 0
 336 0158 13BC      		out 0x23,__zero_reg__
 178:pwm/FastPWM/fastPWM.c **** 	TCNT2 = 0;
 337               		.loc 1 178 0
 338 015a 14BC      		out 0x24,__zero_reg__
 179:pwm/FastPWM/fastPWM.c **** 	// oc2 pin diconnected, normal port operation
 180:pwm/FastPWM/fastPWM.c **** 	TCCR2 &= ~(1<<4);
 339               		.loc 1 180 0
 340 015c 85B5      		in r24,0x25
 341 015e 8F7E      		andi r24,lo8(-17)
 342 0160 85BD      		out 0x25,r24
 181:pwm/FastPWM/fastPWM.c **** 	TCCR2 &= ~(1<<5);
 343               		.loc 1 181 0
 344 0162 85B5      		in r24,0x25
 345 0164 8F7D      		andi r24,lo8(-33)
 346 0166 85BD      		out 0x25,r24
 347 0168 0895      		ret
 348               		.cfi_endproc
 349               	.LFE5:
 351               	.global	fastPWM2_duty
 353               	fastPWM2_duty:
 354               	.LFB4:
 164:pwm/FastPWM/fastPWM.c **** 	// so when pwmstop occurs it can call back pwm function without init again
 355               		.loc 1 164 0
 356               		.cfi_startproc
 357               	.LVL28:
 358               	/* prologue: function */
 359               	/* frame size = 0 */
 360               	/* stack size = 0 */
 361               	.L__stack_usage = 0
 166:pwm/FastPWM/fastPWM.c **** 	if(duty == 0)	fastPWM2_stop();
 362               		.loc 1 166 0
 363 016a 95B5      		in r25,0x25
 364 016c 9062      		ori r25,lo8(32)
 365 016e 95BD      		out 0x25,r25
 167:pwm/FastPWM/fastPWM.c **** 	else	OCR2 = ((duty * 256) / 100) - 1;
 366               		.loc 1 167 0
 367 0170 8111      		cpse r24,__zero_reg__
 368 0172 00C0      		rjmp .L41
 167:pwm/FastPWM/fastPWM.c **** 	else	OCR2 = ((duty * 256) / 100) - 1;
 369               		.loc 1 167 0 is_stmt 0 discriminator 1
 370 0174 0C94 0000 		jmp fastPWM2_stop
 371               	.LVL29:
 372               	.L41:
 168:pwm/FastPWM/fastPWM.c **** }
 373               		.loc 1 168 0 is_stmt 1
 374 0178 982F      		mov r25,r24
 375 017a 80E0      		ldi r24,0
 376               	.LVL30:
 377 017c 64E6      		ldi r22,lo8(100)
 378 017e 70E0      		ldi r23,0
 379 0180 0E94 0000 		call __divmodhi4
 380 0184 6150      		subi r22,lo8(-(-1))
 381 0186 63BD      		out 0x23,r22
 382 0188 0895      		ret
 383               		.cfi_endproc
 384               	.LFE4:
 386               	.global	fastPWM1A_init
 388               	fastPWM1A_init:
 389               	.LFB6:
 182:pwm/FastPWM/fastPWM.c **** }
 183:pwm/FastPWM/fastPWM.c **** 
 184:pwm/FastPWM/fastPWM.c **** /************************************************************************/
 185:pwm/FastPWM/fastPWM.c **** // timer 1
 186:pwm/FastPWM/fastPWM.c **** // OC1A
 187:pwm/FastPWM/fastPWM.c **** 
 188:pwm/FastPWM/fastPWM.c **** //FIXME : make the freq float
 189:pwm/FastPWM/fastPWM.c **** //FIXME : change the hardcoded freq numbers into F_CPU/2... freq dependent numbers
 190:pwm/FastPWM/fastPWM.c **** void fastPWM1A_init(uint32_t freq)
 191:pwm/FastPWM/fastPWM.c **** {
 390               		.loc 1 191 0
 391               		.cfi_startproc
 392               	.LVL31:
 393 018a 0F93      		push r16
 394               	.LCFI0:
 395               		.cfi_def_cfa_offset 3
 396               		.cfi_offset 16, -2
 397 018c 1F93      		push r17
 398               	.LCFI1:
 399               		.cfi_def_cfa_offset 4
 400               		.cfi_offset 17, -3
 401 018e CF93      		push r28
 402               	.LCFI2:
 403               		.cfi_def_cfa_offset 5
 404               		.cfi_offset 28, -4
 405 0190 DF93      		push r29
 406               	.LCFI3:
 407               		.cfi_def_cfa_offset 6
 408               		.cfi_offset 29, -5
 409               	/* prologue: function */
 410               	/* frame size = 0 */
 411               	/* stack size = 4 */
 412               	.L__stack_usage = 4
 413 0192 9B01      		movw r18,r22
 414 0194 AC01      		movw r20,r24
 415               	.LVL32:
 192:pwm/FastPWM/fastPWM.c **** 	// control OC1A only
 193:pwm/FastPWM/fastPWM.c **** 	// this routine works with non-inverted mode only
 194:pwm/FastPWM/fastPWM.c **** 	// and using ICR1 for top value only
 195:pwm/FastPWM/fastPWM.c **** 	uint16_t prescaler = 0;
 196:pwm/FastPWM/fastPWM.c **** 	float ffreq = 0.0;
 197:pwm/FastPWM/fastPWM.c **** 	/* freq can be
 198:pwm/FastPWM/fastPWM.c **** 			top = 0xff  --> f = 62500 : 61 hz		with specific values depending on pre
 199:pwm/FastPWM/fastPWM.c **** 			top = 0x1ff --> f = 31250 : 30 hz   with specific values depending on pre
 200:pwm/FastPWM/fastPWM.c **** 			top = 0x3ff --> f = 15625 : 15 hz   with specific values depending on pre
 201:pwm/FastPWM/fastPWM.c **** 			top = ICR1 || OCR1A
 202:pwm/FastPWM/fastPWM.c **** 					pre = 1    -->  f = 16 M  : 244  hz
 203:pwm/FastPWM/fastPWM.c **** 					pre = 1024 -->  f = 15625 : 0.23 hz
 204:pwm/FastPWM/fastPWM.c **** 	*/
 205:pwm/FastPWM/fastPWM.c **** 	// freq = F_CPU / ((top + 1)*Prescaler)
 206:pwm/FastPWM/fastPWM.c **** 
 207:pwm/FastPWM/fastPWM.c **** 	// set ICR1 with the required value for that freq.
 208:pwm/FastPWM/fastPWM.c **** 	if(freq == 0){
 416               		.loc 1 208 0
 417 0196 6115      		cp r22,__zero_reg__
 418 0198 7105      		cpc r23,__zero_reg__
 419 019a 8105      		cpc r24,__zero_reg__
 420 019c 9105      		cpc r25,__zero_reg__
 421 019e 01F4      		brne .L43
 422               	.LVL33:
 209:pwm/FastPWM/fastPWM.c **** 		prescaler = 1024;
 210:pwm/FastPWM/fastPWM.c **** 		ffreq = 0.23;
 211:pwm/FastPWM/fastPWM.c **** 
 212:pwm/FastPWM/fastPWM.c **** 		ICR1 = (uint16_t)((float)((float)F_CPU / ffreq) / prescaler) - 1;
 423               		.loc 1 212 0
 424 01a0 8EEF      		ldi r24,lo8(-2)
 425 01a2 9FEF      		ldi r25,lo8(-1)
 426 01a4 97BD      		out 0x26+1,r25
 427 01a6 86BD      		out 0x26,r24
 428 01a8 00C0      		rjmp .L44
 429               	.LVL34:
 430               	.L43:
 213:pwm/FastPWM/fastPWM.c **** 	}
 214:pwm/FastPWM/fastPWM.c **** 	else
 215:pwm/FastPWM/fastPWM.c **** 	{
 216:pwm/FastPWM/fastPWM.c ****         // change the 16M to F_CPU
 217:pwm/FastPWM/fastPWM.c **** 		if(freq >= 244 && freq <= 16000000)	prescaler = 1;
 431               		.loc 1 217 0
 432 01aa DC01      		movw r26,r24
 433 01ac CB01      		movw r24,r22
 434 01ae 845F      		subi r24,-12
 435 01b0 9109      		sbc r25,__zero_reg__
 436 01b2 A109      		sbc r26,__zero_reg__
 437 01b4 B109      		sbc r27,__zero_reg__
 438 01b6 8D30      		cpi r24,13
 439 01b8 9342      		sbci r25,35
 440 01ba A44F      		sbci r26,-12
 441 01bc B105      		cpc r27,__zero_reg__
 442               	.LVL35:
 443 01be 00F0      		brlo .L53
 218:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 30 && freq <= 2000000)	prescaler = 8;
 444               		.loc 1 218 0
 445 01c0 DA01      		movw r26,r20
 446 01c2 C901      		movw r24,r18
 447 01c4 4E97      		sbiw r24,30
 448 01c6 A109      		sbc r26,__zero_reg__
 449 01c8 B109      		sbc r27,__zero_reg__
 450 01ca 8336      		cpi r24,99
 451 01cc 9448      		sbci r25,-124
 452 01ce AE41      		sbci r26,30
 453 01d0 B105      		cpc r27,__zero_reg__
 454 01d2 00F0      		brlo .L54
 219:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 4 && freq <= 250000)	prescaler = 64;
 455               		.loc 1 219 0
 456 01d4 DA01      		movw r26,r20
 457 01d6 C901      		movw r24,r18
 458 01d8 0497      		sbiw r24,4
 459 01da A109      		sbc r26,__zero_reg__
 460 01dc B109      		sbc r27,__zero_reg__
 461 01de 8D38      		cpi r24,-115
 462 01e0 904D      		sbci r25,-48
 463 01e2 A340      		sbci r26,3
 464 01e4 B105      		cpc r27,__zero_reg__
 465 01e6 00F0      		brlo .L55
 220:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 1 && freq <= 62500)	prescaler = 256;
 466               		.loc 1 220 0
 467 01e8 DA01      		movw r26,r20
 468 01ea C901      		movw r24,r18
 469 01ec 0197      		sbiw r24,1
 470 01ee A109      		sbc r26,__zero_reg__
 471 01f0 B109      		sbc r27,__zero_reg__
 472 01f2 8432      		cpi r24,36
 473 01f4 944F      		sbci r25,-12
 474 01f6 A105      		cpc r26,__zero_reg__
 475 01f8 B105      		cpc r27,__zero_reg__
 476 01fa 00F0      		brlo .L56
 221:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 0 && freq <= 15625)	prescaler = 1024;
 477               		.loc 1 221 0
 478 01fc 2A30      		cpi r18,10
 479 01fe 8DE3      		ldi r24,61
 480 0200 3807      		cpc r19,r24
 481 0202 4105      		cpc r20,__zero_reg__
 482 0204 5105      		cpc r21,__zero_reg__
 483 0206 00F4      		brsh .L57
 484 0208 C0E0      		ldi r28,0
 485 020a D4E0      		ldi r29,lo8(4)
 486 020c 00C0      		rjmp .L45
 487               	.L53:
 217:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 30 && freq <= 2000000)	prescaler = 8;
 488               		.loc 1 217 0
 489 020e C1E0      		ldi r28,lo8(1)
 490 0210 D0E0      		ldi r29,0
 491 0212 00C0      		rjmp .L45
 492               	.L54:
 218:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 4 && freq <= 250000)	prescaler = 64;
 493               		.loc 1 218 0
 494 0214 C8E0      		ldi r28,lo8(8)
 495 0216 D0E0      		ldi r29,0
 496 0218 00C0      		rjmp .L45
 497               	.L55:
 219:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 1 && freq <= 62500)	prescaler = 256;
 498               		.loc 1 219 0
 499 021a C0E4      		ldi r28,lo8(64)
 500 021c D0E0      		ldi r29,0
 501 021e 00C0      		rjmp .L45
 502               	.L56:
 220:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 0 && freq <= 15625)	prescaler = 1024;
 503               		.loc 1 220 0
 504 0220 C0E0      		ldi r28,0
 505 0222 D1E0      		ldi r29,lo8(1)
 506 0224 00C0      		rjmp .L45
 507               	.L57:
 195:pwm/FastPWM/fastPWM.c **** 	float ffreq = 0.0;
 508               		.loc 1 195 0
 509 0226 C0E0      		ldi r28,0
 510 0228 D0E0      		ldi r29,0
 511               	.L45:
 512               	.LVL36:
 222:pwm/FastPWM/fastPWM.c **** 
 223:pwm/FastPWM/fastPWM.c **** 		ICR1 = (uint16_t)((uint32_t)((uint32_t)F_CPU / freq) / prescaler) - 1;
 513               		.loc 1 223 0
 514 022a 60E0      		ldi r22,0
 515 022c 74E2      		ldi r23,lo8(36)
 516 022e 84EF      		ldi r24,lo8(-12)
 517 0230 90E0      		ldi r25,0
 518 0232 0E94 0000 		call __udivmodsi4
 519               	.LVL37:
 520 0236 CA01      		movw r24,r20
 521 0238 B901      		movw r22,r18
 522 023a 8E01      		movw r16,r28
 523 023c 20E0      		ldi r18,0
 524 023e 30E0      		ldi r19,0
 525 0240 A901      		movw r20,r18
 526 0242 9801      		movw r18,r16
 527 0244 0E94 0000 		call __udivmodsi4
 528 0248 2150      		subi r18,1
 529 024a 3109      		sbc r19,__zero_reg__
 530 024c 37BD      		out 0x26+1,r19
 531 024e 26BD      		out 0x26,r18
 224:pwm/FastPWM/fastPWM.c **** 	}
 225:pwm/FastPWM/fastPWM.c **** 
 226:pwm/FastPWM/fastPWM.c **** 	// set the prescaler in the register & mode 14
 227:pwm/FastPWM/fastPWM.c ****     // edit : made it using bitwise instead of TCCR1A = (1<<1 | (1<<7)
 228:pwm/FastPWM/fastPWM.c ****     //        that disabled me from using both OC1A & OC1B atm..
 229:pwm/FastPWM/fastPWM.c ****     //        now i can use them both but they must have the same freq
 230:pwm/FastPWM/fastPWM.c **** 	switch(prescaler)
 532               		.loc 1 230 0
 533 0250 C034      		cpi r28,64
 534 0252 D105      		cpc r29,__zero_reg__
 535 0254 01F0      		breq .L47
 536 0256 00F4      		brsh .L48
 537 0258 C130      		cpi r28,1
 538 025a D105      		cpc r29,__zero_reg__
 539 025c 01F0      		breq .L46
 540 025e 2897      		sbiw r28,8
 541 0260 01F4      		brne .L46
 542               	.LVL38:
 231:pwm/FastPWM/fastPWM.c **** 	{
 232:pwm/FastPWM/fastPWM.c **** 		case 1:
 233:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<7);
 234:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<0) | (1<<3) | (1<<4);
 235:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<1);
 236:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<2);
 237:pwm/FastPWM/fastPWM.c **** 			break;
 238:pwm/FastPWM/fastPWM.c **** 		case 8:
 239:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<7);
 543               		.loc 1 239 0
 544 0262 8FB5      		in r24,0x2f
 545 0264 8268      		ori r24,lo8(-126)
 546 0266 8FBD      		out 0x2f,r24
 240:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<1) | (1<<3) | (1<<4);
 547               		.loc 1 240 0
 548 0268 8EB5      		in r24,0x2e
 549 026a 8A61      		ori r24,lo8(26)
 550 026c 8EBD      		out 0x2e,r24
 241:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<0);
 551               		.loc 1 241 0
 552 026e 8EB5      		in r24,0x2e
 553 0270 8E7F      		andi r24,lo8(-2)
 554 0272 00C0      		rjmp .L62
 555               	.LVL39:
 556               	.L48:
 230:pwm/FastPWM/fastPWM.c **** 	{
 557               		.loc 1 230 0
 558 0274 C115      		cp r28,__zero_reg__
 559 0276 61E0      		ldi r22,1
 560 0278 D607      		cpc r29,r22
 561 027a 01F0      		breq .L51
 562 027c C115      		cp r28,__zero_reg__
 563 027e D440      		sbci r29,4
 564 0280 01F4      		brne .L46
 565 0282 00C0      		rjmp .L44
 566               	.L47:
 567               	.LVL40:
 242:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<2);
 243:pwm/FastPWM/fastPWM.c **** 			break;
 244:pwm/FastPWM/fastPWM.c **** 		case 64:
 245:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<7);
 568               		.loc 1 245 0
 569 0284 8FB5      		in r24,0x2f
 570 0286 8268      		ori r24,lo8(-126)
 571 0288 8FBD      		out 0x2f,r24
 246:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<0) | (1<<1) | (1<<3) | (1<<4);
 572               		.loc 1 246 0
 573 028a 8EB5      		in r24,0x2e
 574 028c 8B61      		ori r24,lo8(27)
 575 028e 00C0      		rjmp .L62
 576               	.LVL41:
 577               	.L51:
 247:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<2);
 248:pwm/FastPWM/fastPWM.c **** 			break;
 249:pwm/FastPWM/fastPWM.c **** 		case 256:
 250:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<7);
 578               		.loc 1 250 0
 579 0290 8FB5      		in r24,0x2f
 580 0292 8268      		ori r24,lo8(-126)
 581 0294 8FBD      		out 0x2f,r24
 251:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<2) | (1<<3) | (1<<4);
 582               		.loc 1 251 0
 583 0296 8EB5      		in r24,0x2e
 584 0298 8C61      		ori r24,lo8(28)
 585 029a 8EBD      		out 0x2e,r24
 252:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<0);
 586               		.loc 1 252 0
 587 029c 8EB5      		in r24,0x2e
 588 029e 8E7F      		andi r24,lo8(-2)
 589 02a0 00C0      		rjmp .L63
 590               	.LVL42:
 591               	.L44:
 253:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<1);
 254:pwm/FastPWM/fastPWM.c **** 			break;
 255:pwm/FastPWM/fastPWM.c **** 		case 1024:
 256:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<7);
 592               		.loc 1 256 0
 593 02a2 8FB5      		in r24,0x2f
 594 02a4 8268      		ori r24,lo8(-126)
 595 02a6 8FBD      		out 0x2f,r24
 257:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<0) | (1<<2) | (1<<3) | (1<<4);
 596               		.loc 1 257 0
 597 02a8 8EB5      		in r24,0x2e
 598 02aa 8D61      		ori r24,lo8(29)
 599               	.L63:
 600 02ac 8EBD      		out 0x2e,r24
 258:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<1);
 601               		.loc 1 258 0
 602 02ae 8EB5      		in r24,0x2e
 603 02b0 8D7F      		andi r24,lo8(-3)
 604 02b2 00C0      		rjmp .L61
 605               	.LVL43:
 606               	.L46:
 259:pwm/FastPWM/fastPWM.c **** 			break;
 260:pwm/FastPWM/fastPWM.c **** 		default:
 261:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<7);
 607               		.loc 1 261 0
 608 02b4 8FB5      		in r24,0x2f
 609 02b6 8268      		ori r24,lo8(-126)
 610 02b8 8FBD      		out 0x2f,r24
 262:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<0) | (1<<3) | (1<<4);
 611               		.loc 1 262 0
 612 02ba 8EB5      		in r24,0x2e
 613 02bc 8961      		ori r24,lo8(25)
 614 02be 8EBD      		out 0x2e,r24
 263:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<1);
 615               		.loc 1 263 0
 616 02c0 8EB5      		in r24,0x2e
 617 02c2 8D7F      		andi r24,lo8(-3)
 618               	.L62:
 619 02c4 8EBD      		out 0x2e,r24
 264:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<2);
 620               		.loc 1 264 0
 621 02c6 8EB5      		in r24,0x2e
 622 02c8 8B7F      		andi r24,lo8(-5)
 623               	.LVL44:
 624               	.L61:
 625 02ca 8EBD      		out 0x2e,r24
 265:pwm/FastPWM/fastPWM.c **** 			break;
 266:pwm/FastPWM/fastPWM.c **** 	}
 267:pwm/FastPWM/fastPWM.c **** 
 268:pwm/FastPWM/fastPWM.c **** 	// pd5 must be set output ( oc0 )
 269:pwm/FastPWM/fastPWM.c **** 	DDRD |= (1<<PWM1A);
 626               		.loc 1 269 0
 627 02cc 8D9A      		sbi 0x11,5
 270:pwm/FastPWM/fastPWM.c **** 	// init TCNT0 to 0
 271:pwm/FastPWM/fastPWM.c **** 	TCNT1H = 0;
 628               		.loc 1 271 0
 629 02ce 1DBC      		out 0x2d,__zero_reg__
 272:pwm/FastPWM/fastPWM.c **** 	TCNT1L = 0;
 630               		.loc 1 272 0
 631 02d0 1CBC      		out 0x2c,__zero_reg__
 632               	/* epilogue start */
 273:pwm/FastPWM/fastPWM.c **** }
 633               		.loc 1 273 0
 634 02d2 DF91      		pop r29
 635 02d4 CF91      		pop r28
 636 02d6 1F91      		pop r17
 637 02d8 0F91      		pop r16
 638 02da 0895      		ret
 639               		.cfi_endproc
 640               	.LFE6:
 642               	.global	fastPWM1A_stop
 644               	fastPWM1A_stop:
 645               	.LFB8:
 274:pwm/FastPWM/fastPWM.c **** 
 275:pwm/FastPWM/fastPWM.c **** // it is fat better to make the duty cycle input a float for better accuracy
 276:pwm/FastPWM/fastPWM.c **** void fastPWM1A_duty(float duty)
 277:pwm/FastPWM/fastPWM.c **** {
 278:pwm/FastPWM/fastPWM.c **** 	// so when pwmstop occurs it can call back pwm function without init again
 279:pwm/FastPWM/fastPWM.c **** 	TCCR1A |= (1<<7);
 280:pwm/FastPWM/fastPWM.c **** 	// duty cycle = (OCR1x + 1) / (top + 1)
 281:pwm/FastPWM/fastPWM.c **** 	if(duty <= 0)	fastPWM1A_stop();
 282:pwm/FastPWM/fastPWM.c **** 	else	OCR1A = (uint16_t)((float)((float)((float)duty * (float)(ICR1 + 1)) / 100) - 1);
 283:pwm/FastPWM/fastPWM.c **** 	// old : the uint32_t cast is a must here as : duty * ICR1 value cant be stored in 16 bits
 284:pwm/FastPWM/fastPWM.c **** 	// new : made it float for better accuracy
 285:pwm/FastPWM/fastPWM.c **** }
 286:pwm/FastPWM/fastPWM.c **** 
 287:pwm/FastPWM/fastPWM.c **** void fastPWM1A_stop(void)
 288:pwm/FastPWM/fastPWM.c **** {
 646               		.loc 1 288 0
 647               		.cfi_startproc
 648               	/* prologue: function */
 649               	/* frame size = 0 */
 650               	/* stack size = 0 */
 651               	.L__stack_usage = 0
 289:pwm/FastPWM/fastPWM.c **** 	// notice this way you stop timer 0 from all opertaions and when you come back you have to reiniti
 290:pwm/FastPWM/fastPWM.c **** 	//TCCR0 = 0;
 291:pwm/FastPWM/fastPWM.c **** 
 292:pwm/FastPWM/fastPWM.c **** 	// this way you dont stop the timer so you wont need to reinit
 293:pwm/FastPWM/fastPWM.c **** 	OCR1A = 0;
 652               		.loc 1 293 0
 653 02dc 1BBC      		out 0x2a+1,__zero_reg__
 654 02de 1ABC      		out 0x2a,__zero_reg__
 294:pwm/FastPWM/fastPWM.c **** 	TCNT1 = 0;
 655               		.loc 1 294 0
 656 02e0 1DBC      		out 0x2c+1,__zero_reg__
 657 02e2 1CBC      		out 0x2c,__zero_reg__
 295:pwm/FastPWM/fastPWM.c **** 	// oc1A pin diconnected, normal port operation
 296:pwm/FastPWM/fastPWM.c **** 	TCCR1A &= ~(1<<7);
 658               		.loc 1 296 0
 659 02e4 8FB5      		in r24,0x2f
 660 02e6 8F77      		andi r24,lo8(127)
 661 02e8 8FBD      		out 0x2f,r24
 297:pwm/FastPWM/fastPWM.c **** 	TCCR1A &= ~(1<<6);
 662               		.loc 1 297 0
 663 02ea 8FB5      		in r24,0x2f
 664 02ec 8F7B      		andi r24,lo8(-65)
 665 02ee 8FBD      		out 0x2f,r24
 666 02f0 0895      		ret
 667               		.cfi_endproc
 668               	.LFE8:
 670               	.global	__lesf2
 671               	.global	__floatunsisf
 672               	.global	__mulsf3
 673               	.global	__divsf3
 674               	.global	__subsf3
 675               	.global	__fixunssfsi
 676               	.global	fastPWM1A_duty
 678               	fastPWM1A_duty:
 679               	.LFB7:
 277:pwm/FastPWM/fastPWM.c **** 	// so when pwmstop occurs it can call back pwm function without init again
 680               		.loc 1 277 0
 681               		.cfi_startproc
 682               	.LVL45:
 683 02f2 CF92      		push r12
 684               	.LCFI4:
 685               		.cfi_def_cfa_offset 3
 686               		.cfi_offset 12, -2
 687 02f4 DF92      		push r13
 688               	.LCFI5:
 689               		.cfi_def_cfa_offset 4
 690               		.cfi_offset 13, -3
 691 02f6 EF92      		push r14
 692               	.LCFI6:
 693               		.cfi_def_cfa_offset 5
 694               		.cfi_offset 14, -4
 695 02f8 FF92      		push r15
 696               	.LCFI7:
 697               		.cfi_def_cfa_offset 6
 698               		.cfi_offset 15, -5
 699               	/* prologue: function */
 700               	/* frame size = 0 */
 701               	/* stack size = 4 */
 702               	.L__stack_usage = 4
 703 02fa 6B01      		movw r12,r22
 704 02fc 7C01      		movw r14,r24
 279:pwm/FastPWM/fastPWM.c **** 	// duty cycle = (OCR1x + 1) / (top + 1)
 705               		.loc 1 279 0
 706 02fe 8FB5      		in r24,0x2f
 707 0300 8068      		ori r24,lo8(-128)
 708 0302 8FBD      		out 0x2f,r24
 281:pwm/FastPWM/fastPWM.c **** 	else	OCR1A = (uint16_t)((float)((float)((float)duty * (float)(ICR1 + 1)) / 100) - 1);
 709               		.loc 1 281 0
 710 0304 20E0      		ldi r18,0
 711 0306 30E0      		ldi r19,0
 712 0308 A901      		movw r20,r18
 713 030a C701      		movw r24,r14
 714 030c B601      		movw r22,r12
 715               	.LVL46:
 716 030e 0E94 0000 		call __lesf2
 717               	.LVL47:
 718 0312 1816      		cp __zero_reg__,r24
 719 0314 04F0      		brlt .L69
 720               	/* epilogue start */
 285:pwm/FastPWM/fastPWM.c **** 
 721               		.loc 1 285 0 discriminator 1
 722 0316 FF90      		pop r15
 723 0318 EF90      		pop r14
 724 031a DF90      		pop r13
 725 031c CF90      		pop r12
 726               	.LVL48:
 281:pwm/FastPWM/fastPWM.c **** 	else	OCR1A = (uint16_t)((float)((float)((float)duty * (float)(ICR1 + 1)) / 100) - 1);
 727               		.loc 1 281 0 discriminator 1
 728 031e 0C94 0000 		jmp fastPWM1A_stop
 729               	.LVL49:
 730               	.L69:
 282:pwm/FastPWM/fastPWM.c **** 	// old : the uint32_t cast is a must here as : duty * ICR1 value cant be stored in 16 bits
 731               		.loc 1 282 0
 732 0322 86B5      		in r24,0x26
 733 0324 97B5      		in r25,0x26+1
 734 0326 0196      		adiw r24,1
 735 0328 BC01      		movw r22,r24
 736 032a 80E0      		ldi r24,0
 737 032c 90E0      		ldi r25,0
 738 032e 0E94 0000 		call __floatunsisf
 739               	.LVL50:
 740 0332 9B01      		movw r18,r22
 741 0334 AC01      		movw r20,r24
 742 0336 C701      		movw r24,r14
 743 0338 B601      		movw r22,r12
 744 033a 0E94 0000 		call __mulsf3
 745               	.LVL51:
 746 033e 20E0      		ldi r18,0
 747 0340 30E0      		ldi r19,0
 748 0342 48EC      		ldi r20,lo8(-56)
 749 0344 52E4      		ldi r21,lo8(66)
 750 0346 0E94 0000 		call __divsf3
 751               	.LVL52:
 752 034a 20E0      		ldi r18,0
 753 034c 30E0      		ldi r19,0
 754 034e 40E8      		ldi r20,lo8(-128)
 755 0350 5FE3      		ldi r21,lo8(63)
 756 0352 0E94 0000 		call __subsf3
 757               	.LVL53:
 758 0356 0E94 0000 		call __fixunssfsi
 759               	.LVL54:
 760 035a 7BBD      		out 0x2a+1,r23
 761 035c 6ABD      		out 0x2a,r22
 762               	/* epilogue start */
 285:pwm/FastPWM/fastPWM.c **** 
 763               		.loc 1 285 0
 764 035e FF90      		pop r15
 765 0360 EF90      		pop r14
 766 0362 DF90      		pop r13
 767 0364 CF90      		pop r12
 768               	.LVL55:
 769 0366 0895      		ret
 770               		.cfi_endproc
 771               	.LFE7:
 773               	.global	fastPWM1B_init
 775               	fastPWM1B_init:
 776               	.LFB9:
 298:pwm/FastPWM/fastPWM.c **** }
 299:pwm/FastPWM/fastPWM.c **** 
 300:pwm/FastPWM/fastPWM.c **** /**************************************************************************/
 301:pwm/FastPWM/fastPWM.c **** // timer 1
 302:pwm/FastPWM/fastPWM.c **** // OC1B
 303:pwm/FastPWM/fastPWM.c **** 
 304:pwm/FastPWM/fastPWM.c **** //FIXME : make the freq float
 305:pwm/FastPWM/fastPWM.c **** void fastPWM1B_init(uint32_t freq)
 306:pwm/FastPWM/fastPWM.c **** {
 777               		.loc 1 306 0
 778               		.cfi_startproc
 779               	.LVL56:
 780 0368 0F93      		push r16
 781               	.LCFI8:
 782               		.cfi_def_cfa_offset 3
 783               		.cfi_offset 16, -2
 784 036a 1F93      		push r17
 785               	.LCFI9:
 786               		.cfi_def_cfa_offset 4
 787               		.cfi_offset 17, -3
 788 036c CF93      		push r28
 789               	.LCFI10:
 790               		.cfi_def_cfa_offset 5
 791               		.cfi_offset 28, -4
 792 036e DF93      		push r29
 793               	.LCFI11:
 794               		.cfi_def_cfa_offset 6
 795               		.cfi_offset 29, -5
 796               	/* prologue: function */
 797               	/* frame size = 0 */
 798               	/* stack size = 4 */
 799               	.L__stack_usage = 4
 800 0370 9B01      		movw r18,r22
 801 0372 AC01      		movw r20,r24
 802               	.LVL57:
 307:pwm/FastPWM/fastPWM.c **** 	// control OC1B only
 308:pwm/FastPWM/fastPWM.c **** 	// this routine works with non-inverted mode only
 309:pwm/FastPWM/fastPWM.c **** 	// and using ICR1 for top value only
 310:pwm/FastPWM/fastPWM.c **** 	uint16_t prescaler = 0;
 311:pwm/FastPWM/fastPWM.c **** 	float ffreq = 0.0;
 312:pwm/FastPWM/fastPWM.c **** 	/* freq can be
 313:pwm/FastPWM/fastPWM.c **** 			top = 0xff  --> f = 62500 : 61 hz		with specific values depending on pre
 314:pwm/FastPWM/fastPWM.c **** 			top = 0x1ff --> f = 31250 : 30 hz   with specific values depending on pre
 315:pwm/FastPWM/fastPWM.c **** 			top = 0x3ff --> f = 15625 : 15 hz   with specific values depending on pre
 316:pwm/FastPWM/fastPWM.c **** 			top = ICR1 || OCR1A
 317:pwm/FastPWM/fastPWM.c **** 					pre = 1    -->  f = 16 M  : 244  hz
 318:pwm/FastPWM/fastPWM.c **** 					pre = 1024 -->  f = 15625 : 0.23 hz
 319:pwm/FastPWM/fastPWM.c **** 	*/
 320:pwm/FastPWM/fastPWM.c **** 	// freq = F_CPU / ((top + 1)*Prescaler)
 321:pwm/FastPWM/fastPWM.c **** 
 322:pwm/FastPWM/fastPWM.c **** 	// set ICR1 with the required value for that freq.
 323:pwm/FastPWM/fastPWM.c **** 	if(freq == 0){
 803               		.loc 1 323 0
 804 0374 6115      		cp r22,__zero_reg__
 805 0376 7105      		cpc r23,__zero_reg__
 806 0378 8105      		cpc r24,__zero_reg__
 807 037a 9105      		cpc r25,__zero_reg__
 808 037c 01F4      		brne .L71
 809               	.LVL58:
 324:pwm/FastPWM/fastPWM.c **** 		prescaler = 1024;
 325:pwm/FastPWM/fastPWM.c **** 		ffreq = 0.23;
 326:pwm/FastPWM/fastPWM.c **** 
 327:pwm/FastPWM/fastPWM.c **** 		ICR1 = (uint16_t)((float)((float)F_CPU / ffreq) / prescaler) - 1;
 810               		.loc 1 327 0
 811 037e 8EEF      		ldi r24,lo8(-2)
 812 0380 9FEF      		ldi r25,lo8(-1)
 813 0382 97BD      		out 0x26+1,r25
 814 0384 86BD      		out 0x26,r24
 815 0386 00C0      		rjmp .L72
 816               	.LVL59:
 817               	.L71:
 328:pwm/FastPWM/fastPWM.c **** 	}
 329:pwm/FastPWM/fastPWM.c **** 	else
 330:pwm/FastPWM/fastPWM.c **** 	{
 331:pwm/FastPWM/fastPWM.c **** 		if(freq >= 244 && freq <= 16000000)	prescaler = 1;
 818               		.loc 1 331 0
 819 0388 DC01      		movw r26,r24
 820 038a CB01      		movw r24,r22
 821 038c 845F      		subi r24,-12
 822 038e 9109      		sbc r25,__zero_reg__
 823 0390 A109      		sbc r26,__zero_reg__
 824 0392 B109      		sbc r27,__zero_reg__
 825 0394 8D30      		cpi r24,13
 826 0396 9342      		sbci r25,35
 827 0398 A44F      		sbci r26,-12
 828 039a B105      		cpc r27,__zero_reg__
 829               	.LVL60:
 830 039c 00F0      		brlo .L81
 332:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 30 && freq <= 2000000)	prescaler = 8;
 831               		.loc 1 332 0
 832 039e DA01      		movw r26,r20
 833 03a0 C901      		movw r24,r18
 834 03a2 4E97      		sbiw r24,30
 835 03a4 A109      		sbc r26,__zero_reg__
 836 03a6 B109      		sbc r27,__zero_reg__
 837 03a8 8336      		cpi r24,99
 838 03aa 9448      		sbci r25,-124
 839 03ac AE41      		sbci r26,30
 840 03ae B105      		cpc r27,__zero_reg__
 841 03b0 00F0      		brlo .L82
 333:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 4 && freq <= 250000)	prescaler = 64;
 842               		.loc 1 333 0
 843 03b2 DA01      		movw r26,r20
 844 03b4 C901      		movw r24,r18
 845 03b6 0497      		sbiw r24,4
 846 03b8 A109      		sbc r26,__zero_reg__
 847 03ba B109      		sbc r27,__zero_reg__
 848 03bc 8D38      		cpi r24,-115
 849 03be 904D      		sbci r25,-48
 850 03c0 A340      		sbci r26,3
 851 03c2 B105      		cpc r27,__zero_reg__
 852 03c4 00F0      		brlo .L83
 334:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 1 && freq <= 62500)	prescaler = 256;
 853               		.loc 1 334 0
 854 03c6 DA01      		movw r26,r20
 855 03c8 C901      		movw r24,r18
 856 03ca 0197      		sbiw r24,1
 857 03cc A109      		sbc r26,__zero_reg__
 858 03ce B109      		sbc r27,__zero_reg__
 859 03d0 8432      		cpi r24,36
 860 03d2 944F      		sbci r25,-12
 861 03d4 A105      		cpc r26,__zero_reg__
 862 03d6 B105      		cpc r27,__zero_reg__
 863 03d8 00F0      		brlo .L84
 335:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 0 && freq <= 15625)	prescaler = 1024;
 864               		.loc 1 335 0
 865 03da 2A30      		cpi r18,10
 866 03dc 8DE3      		ldi r24,61
 867 03de 3807      		cpc r19,r24
 868 03e0 4105      		cpc r20,__zero_reg__
 869 03e2 5105      		cpc r21,__zero_reg__
 870 03e4 00F4      		brsh .L85
 871 03e6 C0E0      		ldi r28,0
 872 03e8 D4E0      		ldi r29,lo8(4)
 873 03ea 00C0      		rjmp .L73
 874               	.L81:
 331:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 30 && freq <= 2000000)	prescaler = 8;
 875               		.loc 1 331 0
 876 03ec C1E0      		ldi r28,lo8(1)
 877 03ee D0E0      		ldi r29,0
 878 03f0 00C0      		rjmp .L73
 879               	.L82:
 332:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 4 && freq <= 250000)	prescaler = 64;
 880               		.loc 1 332 0
 881 03f2 C8E0      		ldi r28,lo8(8)
 882 03f4 D0E0      		ldi r29,0
 883 03f6 00C0      		rjmp .L73
 884               	.L83:
 333:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 1 && freq <= 62500)	prescaler = 256;
 885               		.loc 1 333 0
 886 03f8 C0E4      		ldi r28,lo8(64)
 887 03fa D0E0      		ldi r29,0
 888 03fc 00C0      		rjmp .L73
 889               	.L84:
 334:pwm/FastPWM/fastPWM.c **** 		else if(freq >= 0 && freq <= 15625)	prescaler = 1024;
 890               		.loc 1 334 0
 891 03fe C0E0      		ldi r28,0
 892 0400 D1E0      		ldi r29,lo8(1)
 893 0402 00C0      		rjmp .L73
 894               	.L85:
 310:pwm/FastPWM/fastPWM.c **** 	float ffreq = 0.0;
 895               		.loc 1 310 0
 896 0404 C0E0      		ldi r28,0
 897 0406 D0E0      		ldi r29,0
 898               	.L73:
 899               	.LVL61:
 336:pwm/FastPWM/fastPWM.c **** 
 337:pwm/FastPWM/fastPWM.c **** 		ICR1 = (uint16_t)((uint32_t)((uint32_t)F_CPU / freq) / prescaler) - 1;
 900               		.loc 1 337 0
 901 0408 60E0      		ldi r22,0
 902 040a 74E2      		ldi r23,lo8(36)
 903 040c 84EF      		ldi r24,lo8(-12)
 904 040e 90E0      		ldi r25,0
 905 0410 0E94 0000 		call __udivmodsi4
 906               	.LVL62:
 907 0414 CA01      		movw r24,r20
 908 0416 B901      		movw r22,r18
 909 0418 8E01      		movw r16,r28
 910 041a 20E0      		ldi r18,0
 911 041c 30E0      		ldi r19,0
 912 041e A901      		movw r20,r18
 913 0420 9801      		movw r18,r16
 914 0422 0E94 0000 		call __udivmodsi4
 915 0426 2150      		subi r18,1
 916 0428 3109      		sbc r19,__zero_reg__
 917 042a 37BD      		out 0x26+1,r19
 918 042c 26BD      		out 0x26,r18
 338:pwm/FastPWM/fastPWM.c **** 	}
 339:pwm/FastPWM/fastPWM.c **** 
 340:pwm/FastPWM/fastPWM.c **** 	// set the prescaler in the register & mode 14
 341:pwm/FastPWM/fastPWM.c ****     // edit : made it using bitwise instead of TCCR1A = (1<<1 | (1<<7)
 342:pwm/FastPWM/fastPWM.c ****     //        that disabled me from using both OC1A & OC1B atm..
 343:pwm/FastPWM/fastPWM.c ****     //        now i can use them both but they must have the same freq
 344:pwm/FastPWM/fastPWM.c **** 	switch(prescaler)
 919               		.loc 1 344 0
 920 042e C034      		cpi r28,64
 921 0430 D105      		cpc r29,__zero_reg__
 922 0432 01F0      		breq .L75
 923 0434 00F4      		brsh .L76
 924 0436 C130      		cpi r28,1
 925 0438 D105      		cpc r29,__zero_reg__
 926 043a 01F0      		breq .L74
 927 043c 2897      		sbiw r28,8
 928 043e 01F4      		brne .L74
 929               	.LVL63:
 345:pwm/FastPWM/fastPWM.c **** 	{
 346:pwm/FastPWM/fastPWM.c **** 		case 1:
 347:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<5);
 348:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<0) | (1<<3) | (1<<4);
 349:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<1);
 350:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<2);
 351:pwm/FastPWM/fastPWM.c **** 			break;
 352:pwm/FastPWM/fastPWM.c **** 		case 8:
 353:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<5);
 930               		.loc 1 353 0
 931 0440 8FB5      		in r24,0x2f
 932 0442 8262      		ori r24,lo8(34)
 933 0444 8FBD      		out 0x2f,r24
 354:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<1) | (1<<3) | (1<<4);
 934               		.loc 1 354 0
 935 0446 8EB5      		in r24,0x2e
 936 0448 8A61      		ori r24,lo8(26)
 937 044a 8EBD      		out 0x2e,r24
 355:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<0);
 938               		.loc 1 355 0
 939 044c 8EB5      		in r24,0x2e
 940 044e 8E7F      		andi r24,lo8(-2)
 941 0450 00C0      		rjmp .L90
 942               	.LVL64:
 943               	.L76:
 344:pwm/FastPWM/fastPWM.c **** 	{
 944               		.loc 1 344 0
 945 0452 C115      		cp r28,__zero_reg__
 946 0454 61E0      		ldi r22,1
 947 0456 D607      		cpc r29,r22
 948 0458 01F0      		breq .L79
 949 045a C115      		cp r28,__zero_reg__
 950 045c D440      		sbci r29,4
 951 045e 01F4      		brne .L74
 952 0460 00C0      		rjmp .L72
 953               	.L75:
 954               	.LVL65:
 356:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<2);
 357:pwm/FastPWM/fastPWM.c **** 			break;
 358:pwm/FastPWM/fastPWM.c **** 		case 64:
 359:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<5);
 955               		.loc 1 359 0
 956 0462 8FB5      		in r24,0x2f
 957 0464 8262      		ori r24,lo8(34)
 958 0466 8FBD      		out 0x2f,r24
 360:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<0) | (1<<1) | (1<<3) | (1<<4);
 959               		.loc 1 360 0
 960 0468 8EB5      		in r24,0x2e
 961 046a 8B61      		ori r24,lo8(27)
 962 046c 00C0      		rjmp .L90
 963               	.LVL66:
 964               	.L79:
 361:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<2);
 362:pwm/FastPWM/fastPWM.c **** 			break;
 363:pwm/FastPWM/fastPWM.c **** 		case 256:
 364:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<5);
 965               		.loc 1 364 0
 966 046e 8FB5      		in r24,0x2f
 967 0470 8262      		ori r24,lo8(34)
 968 0472 8FBD      		out 0x2f,r24
 365:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<2) | (1<<3) | (1<<4);
 969               		.loc 1 365 0
 970 0474 8EB5      		in r24,0x2e
 971 0476 8C61      		ori r24,lo8(28)
 972 0478 8EBD      		out 0x2e,r24
 366:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<0);
 973               		.loc 1 366 0
 974 047a 8EB5      		in r24,0x2e
 975 047c 8E7F      		andi r24,lo8(-2)
 976 047e 00C0      		rjmp .L91
 977               	.LVL67:
 978               	.L72:
 367:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<1);
 368:pwm/FastPWM/fastPWM.c **** 			break;
 369:pwm/FastPWM/fastPWM.c **** 		case 1024:
 370:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<5);
 979               		.loc 1 370 0
 980 0480 8FB5      		in r24,0x2f
 981 0482 8262      		ori r24,lo8(34)
 982 0484 8FBD      		out 0x2f,r24
 371:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<0) | (1<<2) | (1<<3) | (1<<4);
 983               		.loc 1 371 0
 984 0486 8EB5      		in r24,0x2e
 985 0488 8D61      		ori r24,lo8(29)
 986               	.L91:
 987 048a 8EBD      		out 0x2e,r24
 372:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<1);
 988               		.loc 1 372 0
 989 048c 8EB5      		in r24,0x2e
 990 048e 8D7F      		andi r24,lo8(-3)
 991 0490 00C0      		rjmp .L89
 992               	.LVL68:
 993               	.L74:
 373:pwm/FastPWM/fastPWM.c **** 			break;
 374:pwm/FastPWM/fastPWM.c **** 		default:
 375:pwm/FastPWM/fastPWM.c **** 			TCCR1A |= (1<<1) | (1<<5);
 994               		.loc 1 375 0
 995 0492 8FB5      		in r24,0x2f
 996 0494 8262      		ori r24,lo8(34)
 997 0496 8FBD      		out 0x2f,r24
 376:pwm/FastPWM/fastPWM.c **** 			TCCR1B |= (1<<0) | (1<<3) | (1<<4);
 998               		.loc 1 376 0
 999 0498 8EB5      		in r24,0x2e
 1000 049a 8961      		ori r24,lo8(25)
 1001 049c 8EBD      		out 0x2e,r24
 377:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<1);
 1002               		.loc 1 377 0
 1003 049e 8EB5      		in r24,0x2e
 1004 04a0 8D7F      		andi r24,lo8(-3)
 1005               	.L90:
 1006 04a2 8EBD      		out 0x2e,r24
 378:pwm/FastPWM/fastPWM.c **** 			TCCR1B &= ~(1<<2);
 1007               		.loc 1 378 0
 1008 04a4 8EB5      		in r24,0x2e
 1009 04a6 8B7F      		andi r24,lo8(-5)
 1010               	.LVL69:
 1011               	.L89:
 1012 04a8 8EBD      		out 0x2e,r24
 379:pwm/FastPWM/fastPWM.c **** 			break;
 380:pwm/FastPWM/fastPWM.c **** 	}
 381:pwm/FastPWM/fastPWM.c **** 
 382:pwm/FastPWM/fastPWM.c **** 	// pd5 must be set output ( oc0 )
 383:pwm/FastPWM/fastPWM.c **** 	DDRD |= (1<<PWM1B);
 1013               		.loc 1 383 0
 1014 04aa 8C9A      		sbi 0x11,4
 384:pwm/FastPWM/fastPWM.c **** 	// init TCNT0 to 0
 385:pwm/FastPWM/fastPWM.c **** 	TCNT1H = 0;
 1015               		.loc 1 385 0
 1016 04ac 1DBC      		out 0x2d,__zero_reg__
 386:pwm/FastPWM/fastPWM.c **** 	TCNT1L = 0;
 1017               		.loc 1 386 0
 1018 04ae 1CBC      		out 0x2c,__zero_reg__
 1019               	/* epilogue start */
 387:pwm/FastPWM/fastPWM.c **** }
 1020               		.loc 1 387 0
 1021 04b0 DF91      		pop r29
 1022 04b2 CF91      		pop r28
 1023 04b4 1F91      		pop r17
 1024 04b6 0F91      		pop r16
 1025 04b8 0895      		ret
 1026               		.cfi_endproc
 1027               	.LFE9:
 1029               	.global	fastPWM1B_stop
 1031               	fastPWM1B_stop:
 1032               	.LFB11:
 388:pwm/FastPWM/fastPWM.c **** 
 389:pwm/FastPWM/fastPWM.c **** void fastPWM1B_duty(float duty)
 390:pwm/FastPWM/fastPWM.c **** {
 391:pwm/FastPWM/fastPWM.c **** 	// so when pwmstop occurs it can call back pwm function without init again
 392:pwm/FastPWM/fastPWM.c **** 	TCCR1B |= (1<<5);
 393:pwm/FastPWM/fastPWM.c **** 	// duty cycle = (OCR1x + 1) / (top + 1)
 394:pwm/FastPWM/fastPWM.c **** 	if(duty <= 0)	fastPWM1B_stop();
 395:pwm/FastPWM/fastPWM.c **** 	else	OCR1B = (uint16_t)((float)((float)((float)duty * (float)(ICR1 + 1)) / 100) - 1);
 396:pwm/FastPWM/fastPWM.c **** 	// old : the uint32_t cast is a must here as : duty * ICR1 value cant be stored in 16 bits
 397:pwm/FastPWM/fastPWM.c **** 	// new : made it float for better accuracy
 398:pwm/FastPWM/fastPWM.c **** }
 399:pwm/FastPWM/fastPWM.c **** 
 400:pwm/FastPWM/fastPWM.c **** void fastPWM1B_stop(void)
 401:pwm/FastPWM/fastPWM.c **** {
 1033               		.loc 1 401 0
 1034               		.cfi_startproc
 1035               	/* prologue: function */
 1036               	/* frame size = 0 */
 1037               	/* stack size = 0 */
 1038               	.L__stack_usage = 0
 402:pwm/FastPWM/fastPWM.c **** 	// notice this way you stop timer 0 from all opertaions and when you come back you have to reiniti
 403:pwm/FastPWM/fastPWM.c **** 	//TCCR0 = 0;
 404:pwm/FastPWM/fastPWM.c **** 
 405:pwm/FastPWM/fastPWM.c **** 	// this way you dont stop the timer so you wont need to reinit
 406:pwm/FastPWM/fastPWM.c **** 	OCR1B = 0;
 1039               		.loc 1 406 0
 1040 04ba 19BC      		out 0x28+1,__zero_reg__
 1041 04bc 18BC      		out 0x28,__zero_reg__
 407:pwm/FastPWM/fastPWM.c **** 	TCNT1 = 0;
 1042               		.loc 1 407 0
 1043 04be 1DBC      		out 0x2c+1,__zero_reg__
 1044 04c0 1CBC      		out 0x2c,__zero_reg__
 408:pwm/FastPWM/fastPWM.c **** 	// oc1B pin diconnected, normal port operation
 409:pwm/FastPWM/fastPWM.c **** 	TCCR1A &= ~(1<<5);
 1045               		.loc 1 409 0
 1046 04c2 8FB5      		in r24,0x2f
 1047 04c4 8F7D      		andi r24,lo8(-33)
 1048 04c6 8FBD      		out 0x2f,r24
 410:pwm/FastPWM/fastPWM.c **** 	TCCR1A &= ~(1<<4);
 1049               		.loc 1 410 0
 1050 04c8 8FB5      		in r24,0x2f
 1051 04ca 8F7E      		andi r24,lo8(-17)
 1052 04cc 8FBD      		out 0x2f,r24
 1053 04ce 0895      		ret
 1054               		.cfi_endproc
 1055               	.LFE11:
 1057               	.global	fastPWM1B_duty
 1059               	fastPWM1B_duty:
 1060               	.LFB10:
 390:pwm/FastPWM/fastPWM.c **** 	// so when pwmstop occurs it can call back pwm function without init again
 1061               		.loc 1 390 0
 1062               		.cfi_startproc
 1063               	.LVL70:
 1064 04d0 CF92      		push r12
 1065               	.LCFI12:
 1066               		.cfi_def_cfa_offset 3
 1067               		.cfi_offset 12, -2
 1068 04d2 DF92      		push r13
 1069               	.LCFI13:
 1070               		.cfi_def_cfa_offset 4
 1071               		.cfi_offset 13, -3
 1072 04d4 EF92      		push r14
 1073               	.LCFI14:
 1074               		.cfi_def_cfa_offset 5
 1075               		.cfi_offset 14, -4
 1076 04d6 FF92      		push r15
 1077               	.LCFI15:
 1078               		.cfi_def_cfa_offset 6
 1079               		.cfi_offset 15, -5
 1080               	/* prologue: function */
 1081               	/* frame size = 0 */
 1082               	/* stack size = 4 */
 1083               	.L__stack_usage = 4
 1084 04d8 6B01      		movw r12,r22
 1085 04da 7C01      		movw r14,r24
 392:pwm/FastPWM/fastPWM.c **** 	// duty cycle = (OCR1x + 1) / (top + 1)
 1086               		.loc 1 392 0
 1087 04dc 8EB5      		in r24,0x2e
 1088 04de 8062      		ori r24,lo8(32)
 1089 04e0 8EBD      		out 0x2e,r24
 394:pwm/FastPWM/fastPWM.c **** 	else	OCR1B = (uint16_t)((float)((float)((float)duty * (float)(ICR1 + 1)) / 100) - 1);
 1090               		.loc 1 394 0
 1091 04e2 20E0      		ldi r18,0
 1092 04e4 30E0      		ldi r19,0
 1093 04e6 A901      		movw r20,r18
 1094 04e8 C701      		movw r24,r14
 1095 04ea B601      		movw r22,r12
 1096               	.LVL71:
 1097 04ec 0E94 0000 		call __lesf2
 1098               	.LVL72:
 1099 04f0 1816      		cp __zero_reg__,r24
 1100 04f2 04F0      		brlt .L97
 1101               	/* epilogue start */
 398:pwm/FastPWM/fastPWM.c **** 
 1102               		.loc 1 398 0 discriminator 1
 1103 04f4 FF90      		pop r15
 1104 04f6 EF90      		pop r14
 1105 04f8 DF90      		pop r13
 1106 04fa CF90      		pop r12
 1107               	.LVL73:
 394:pwm/FastPWM/fastPWM.c **** 	else	OCR1B = (uint16_t)((float)((float)((float)duty * (float)(ICR1 + 1)) / 100) - 1);
 1108               		.loc 1 394 0 discriminator 1
 1109 04fc 0C94 0000 		jmp fastPWM1B_stop
 1110               	.LVL74:
 1111               	.L97:
 395:pwm/FastPWM/fastPWM.c **** 	// old : the uint32_t cast is a must here as : duty * ICR1 value cant be stored in 16 bits
 1112               		.loc 1 395 0
 1113 0500 86B5      		in r24,0x26
 1114 0502 97B5      		in r25,0x26+1
 1115 0504 0196      		adiw r24,1
 1116 0506 BC01      		movw r22,r24
 1117 0508 80E0      		ldi r24,0
 1118 050a 90E0      		ldi r25,0
 1119 050c 0E94 0000 		call __floatunsisf
 1120               	.LVL75:
 1121 0510 9B01      		movw r18,r22
 1122 0512 AC01      		movw r20,r24
 1123 0514 C701      		movw r24,r14
 1124 0516 B601      		movw r22,r12
 1125 0518 0E94 0000 		call __mulsf3
 1126               	.LVL76:
 1127 051c 20E0      		ldi r18,0
 1128 051e 30E0      		ldi r19,0
 1129 0520 48EC      		ldi r20,lo8(-56)
 1130 0522 52E4      		ldi r21,lo8(66)
 1131 0524 0E94 0000 		call __divsf3
 1132               	.LVL77:
 1133 0528 20E0      		ldi r18,0
 1134 052a 30E0      		ldi r19,0
 1135 052c 40E8      		ldi r20,lo8(-128)
 1136 052e 5FE3      		ldi r21,lo8(63)
 1137 0530 0E94 0000 		call __subsf3
 1138               	.LVL78:
 1139 0534 0E94 0000 		call __fixunssfsi
 1140               	.LVL79:
 1141 0538 79BD      		out 0x28+1,r23
 1142 053a 68BD      		out 0x28,r22
 1143               	/* epilogue start */
 398:pwm/FastPWM/fastPWM.c **** 
 1144               		.loc 1 398 0
 1145 053c FF90      		pop r15
 1146 053e EF90      		pop r14
 1147 0540 DF90      		pop r13
 1148 0542 CF90      		pop r12
 1149               	.LVL80:
 1150 0544 0895      		ret
 1151               		.cfi_endproc
 1152               	.LFE10:
 1154               	.Letext0:
 1155               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fastPWM.c
     /tmp/ccaes5NP.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccaes5NP.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccaes5NP.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccaes5NP.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccaes5NP.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccaes5NP.s:12     .text:0000000000000000 fastPWM0_init
     /tmp/ccaes5NP.s:126    .text:0000000000000082 fastPWM0_stop
     /tmp/ccaes5NP.s:152    .text:0000000000000094 fastPWM0_duty
     /tmp/ccaes5NP.s:187    .text:00000000000000b4 fastPWM2_init
     /tmp/ccaes5NP.s:327    .text:0000000000000158 fastPWM2_stop
     /tmp/ccaes5NP.s:353    .text:000000000000016a fastPWM2_duty
     /tmp/ccaes5NP.s:388    .text:000000000000018a fastPWM1A_init
     /tmp/ccaes5NP.s:644    .text:00000000000002dc fastPWM1A_stop
     /tmp/ccaes5NP.s:678    .text:00000000000002f2 fastPWM1A_duty
     /tmp/ccaes5NP.s:775    .text:0000000000000368 fastPWM1B_init
     /tmp/ccaes5NP.s:1031   .text:00000000000004ba fastPWM1B_stop
     /tmp/ccaes5NP.s:1059   .text:00000000000004d0 fastPWM1B_duty

UNDEFINED SYMBOLS
__udivmodsi4
__divmodhi4
__lesf2
__floatunsisf
__mulsf3
__divsf3
__subsf3
__fixunssfsi
